<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<Meta name="ExplicitAutoJoints">true</Meta>
	<External>null</External>
	<External>nil</External>
	<Item class="Folder" referent="RBX8C3B0D17FA804512B986CFE572486156">
		<Properties>
			<string name="Name">Files</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Configuration" referent="RBXD23CF595DA8A45E4847D350F24DBB9D8">
			<Properties>
				<string name="Name">StarterPlayer</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Configuration" referent="RBXD06E2826E13A4A4DADF3CE19C1320DCD">
				<Properties>
					<string name="Name">StarterPlayerScripts</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="LocalScript" referent="RBXC2260E3E436542538EB93880BB77CA47">
					<Properties>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">PlrProbe</string>
						<string name="ScriptGuid">{363317DE-ADDF-4422-BDD6-F5C3C442D97D}</string>
						<ProtectedString name="Source"><![CDATA[joy1 = {}
joy1.Delta = Vector3.new(0,0,0)
joy1.Position = Vector3.new(0,0,0)
joy2 = {}
joy2.Delta = Vector3.new(0,0,0)
joy2.Position = Vector3.new(0,0,0)
plr = game.Players.LocalPlayer
mouse = plr:GetMouse()
camera = workspace.CurrentCamera
cc = game.ReplicatedStorage.Events.Players:WaitForChild(plr.Name)
idle = 0
uis = game:GetService("UserInputService")
uis.InputChanged:Connect(function(input,gp)
	if input.KeyCode == Enum.KeyCode.Thumbstick1 then
		joy1.Delta = input.Delta
		joy1.Position = input.Position
	elseif input.KeyCode == Enum.KeyCode.Thumbstick2 then
		joy2.Delta = input.Delta
		joy2.Position = input.Position
	end
end)
uis.InputBegan:Connect(function(input, gpe)
	cc.KeyDown:FireServer(input.KeyCode)
end)
uis.InputEnded:Connect(function(input, gpe)
	cc.KeyUp:FireServer(input.KeyCode)
end)

mouse.Button1Down:Connect(function() cc.b1d:FireServer() end)
mouse.Button1Up:Connect(function() cc.b1u:FireServer() end)
mouse.Button2Down:Connect(function() cc.b2d:FireServer() end)
mouse.Button2Up:Connect(function() cc.b2d:FireServer() end)
mouse.Move:Connect(function() idle = 1 end)
mouse.Idle:Connect(function() idle = 0 end)
plr.Chatted:Connect(function(msg) cc.Chat:FireServer(msg) end)
tabinput = {}
cc.changestate.OnClientEvent:Connect(function(hum,state,bool)
	hum:SetStateEnabled(state,bool)
end)
while wait(1/30) do
	local gui
	if uis:GetFocusedTextBox() then
		gui = true
	else
		gui = false
	end
	cc.joystick:FireServer(joy1,joy2)
	tabinput = {Accelerometer = uis.AccelerometerEnabled,Gamepad = uis.GamepadEnabled,Gyroscope = uis.GyroscopeEnabled,Keyboard = uis.KeyboardEnabled,Modal = uis.ModalEnabled,Mouse = uis.MouseEnabled,Touch = uis.TouchEnabled,VR = uis.VREnabled}
	cc.gui:FireServer(gui)
	cc.type:FireServer(tabinput)
	cc.Mouse:FireServer(mouse.hit, mouse.target, mouse.origin)
	if idle == 1 then
		cc.mMove:FireServer()
	else
		cc.mIdle:FireServer()
	end
	cc.Camera:FireServer(camera.CFrame)
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="Configuration" referent="RBX14F7231694E94CF08C8BFEB27F2F0D01">
			<Properties>
				<string name="Name">ReplicatedStorage</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Folder" referent="RBXD7F5031196BC489F823B6179BA9711CC">
				<Properties>
					<string name="Name">Events</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBX09E127E8A40A4E8B987C0448F7F3C9FB">
					<Properties>
						<string name="Name">Players</string>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX8AEE3859039248D2834E3899EFDDFF78">
				<Properties>
					<string name="Name">PlayerFold</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBXE3E082B0EF4C40E48A8423FDE4F42D00">
					<Properties>
						<string name="Name">Folder</string>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="RemoteEvent" referent="RBXD3100A8AB4A745A7B9C5F06C497468D3">
						<Properties>
							<string name="Name">Camera</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBXB28EB0D4C8CA4A86B79AAB90684F1266">
						<Properties>
							<string name="Name">Chat</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX97DB1F8AAF7A408A9F149F836B3BF739">
						<Properties>
							<string name="Name">KeyDown</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBXF7105999289141FC9609DA21ABD4854A">
						<Properties>
							<string name="Name">KeyUp</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBXB6ED614988CD4A41AEBC2464169C5693">
						<Properties>
							<string name="Name">Mouse</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBXBD5DCF9F42D5430AB07847299B86F0B2">
						<Properties>
							<string name="Name">b1d</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBXF1379A58E5884E81AACAED3590435F39">
						<Properties>
							<string name="Name">b1u</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX426E6A88B318433891963490C56F7964">
						<Properties>
							<string name="Name">b2d</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX9B6D1437CC6D42FBA30262088B68B4AA">
						<Properties>
							<string name="Name">b2u</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX8799BE0065E541F8A0A7D50D883A71D5">
						<Properties>
							<string name="Name">mIdle</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBXDA092032D56D49C687BD0AD06EFC747F">
						<Properties>
							<string name="Name">mMove</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXC79DAB4F89854D7886F1B9A47B7E9848">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Input</string>
							<string name="ScriptGuid">{136C0D38-AF84-4D3D-B718-5E031657CB94}</string>
							<ProtectedString name="Source"><![CDATA[modtable = {}
local cc = script.Parent
plr = game.Players[script.Parent.Name]
Mouse = {}
Mouse.hit = CFrame.new()
Mouse.target = nil
Mouse.origin = CFrame.new()
cc.Mouse.OnServerEvent:Connect(function(p, m1, m2, m3)
	if p ~= plr then return end
	modtable.MouseCframe = m1
	modtable.MouseTarget = m2
	modtable.MouseOrigin = m3
end)
local mkd = Instance.new("BindableEvent", cc)
local mku = Instance.new("BindableEvent", cc)
cc.KeyDown.OnServerEvent:Connect(function(p, k) if p ~= plr then return end mkd:Fire(k) end)
cc.KeyUp.OnServerEvent:Connect(function(p, k) if p ~= plr then return end mku:Fire(k) end)
modtable.KeyDown = mkd.Event
modtable.KeyUp = mku.Event
Button1Down = Instance.new("BindableEvent",cc)
Button1Up = Instance.new("BindableEvent",cc)
Button2Down = Instance.new("BindableEvent",cc)
Button2Up = Instance.new("BindableEvent",cc)
cc.b1d.OnServerEvent:Connect(function(p)
	if p ~= plr then return end
	Button1Down:Fire()
end)
cc.b1u.OnServerEvent:Connect(function(p)
	if p ~= plr then return end
	Button1Up:Fire()
end)
cc.b2d.OnServerEvent:Connect(function(p)
	if p ~= plr then return end
	Button2Down:Fire()
end)
cc.b2u.OnServerEvent:Connect(function(p)
	if p ~= plr then return end
	Button2Up:Fire()
end)
modtable.Button1Down = Button1Down.Event
modtable.Button1Up = Button1Up.Event
modtable.Button2Down = Button2Down.Event
modtable.Button2Up = Button2Up.Event

Camera = {}
modtable.CameraCframe = CFrame.new()
local mm = Instance.new("BindableEvent", cc)
local mi = Instance.new("BindableEvent", cc)
cc.Camera.OnServerEvent:Connect(function(p,val) if p ~= plr then return end modtable.CameraCframe = val end)
local ms = true
cc.mMove.OnServerEvent:Connect(function(p) if p ~= plr then return end ms = 1 end)
cc.mIdle.OnServerEvent:Connect(function(p) if p ~= plr then return end ms = 0 end)
local function mousem() 
	if ms == 1 then
		mm:Fire()
	elseif ms == 0 then
		mi:Fire()
	end
end
game:GetService('RunService').Heartbeat:Connect(mousem)
modtable.MouseMove = mm.Event
modtable.MouseIdle = mi.Event
local chat = Instance.new("BindableEvent", script)
cc.Chat.OnServerEvent:Connect(function(p, msg) if p ~= plr then return end chat:Fire(msg) end)
modtable.Chatted = chat.Event
modtable.Type = nil
modtable.IsInGui = false
cc.gui.OnServerEvent:Connect(function(p,gui)
	if p ~= plr then return end
	modtable.IsInGui = gui
end)
cc.type.OnServerEvent:Connect(function(p,type1)
	if p ~= plr then return end
	modtable.Type = type1
	for i,v in ipairs(type1) do
			print(v)
	end
end)
modtable.JoyStick1 = nil
modtable.JoyStick2 = nil
cc.joystick.OnServerEvent:Connect(function(p,joy1,joy2)
	if p ~= plr then return end
	modtable.JoyStick1 = joy1
	modtable.JoyStick2 = joy2
end)


return modtable

]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBXA5F5AE8D1051418E9B4A6F357909D384">
						<Properties>
							<string name="Name">type</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBXC010C1515028481FA04E995F64F9EE7D">
						<Properties>
							<string name="Name">gui</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX4B39C2B29087413EB9C3681927206B63">
						<Properties>
							<string name="Name">joystick</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBXC75685851541488CB7DFDDA78BB2D903">
						<Properties>
							<string name="Name">changestate</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
		</Item>
		<Item class="Configuration" referent="RBXDC202AD39CE74915999672BE3269E138">
			<Properties>
				<string name="Name">ServerScriptService</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Script" referent="RBXFE2053555BE44017A5A1583EACBA028F">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">DirusEngine</string>
					<string name="ScriptGuid">{A84FB564-3878-4379-A732-CBBFBEA77386}</string>
					<ProtectedString name="Source"><![CDATA[game.Players.PlayerAdded:Connect(function(plr)
	local fold = game.ReplicatedStorage.PlayerFold.Folder:Clone()
	fold.Name = plr.Name
	fold.Parent = game.ReplicatedStorage.Events.Players
end)
function code() end
require(script.Get,getfenv(code))]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX0BA4CE25AC9042D0BC6F3FE35E117C5A">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">PlayerLib</string>
						<string name="ScriptGuid">{0F3EF167-F707-43D0-A8DD-40A0716F71EA}</string>
						<ProtectedString name="Source"><![CDATA[modtable = {}
groupservice = game:GetService("GroupService")
httpserice = game:GetService("HttpService")
function getwebdata(link)
	local tab = {}
	local num = 1
	repeat
		local json = httpserice:GetAsync(link .."?page=" ..num)
		for i, v in pairs(httpserice:JSONDecode(json)) do
			tab[#tab + 1] = modtable:GetInfo(v.Id)
		end
		num = num + 1
	until #(httpserice:JSONDecode(httpserice:GetAsync(link .."?page=" ..num))) == 0
	return tab
end
function getfriends(id)
	local page = game.Players:GetFriendsAsync(id)
	local table1 = {}
	local b = 0
	for i,v in pairs(getwebdata("https://api.rprxy.xyz/users/" ..id .."/friends")) do
		b = b + 1
		table1[b] = v
	end
	return table1
end
function getgroups(id)
	local table1 = {}
	local groups = groupservice:GetGroupsAsync(id)
	for i,group1 in ipairs(groups) do
		local group2 = groupservice:GetGroupInfoAsync(group1.Id)
		local table2 = {
			Name = group2.Name,
			Id = group2.Id,
			Emblem = group2.EmblemUrl,
			Description = group2.Description,
			Roles = group2.Roles,
			PlayerPrimary = group1.IsPrimary,
			PlayerClan = group1.IsInClan,
			PlayerRank = group1.Rank,
			PlayerRole = group1.Role,
		}
		if group2.Owner then
			table2.Owner = modtable:GetInfo(group2.Owner.Id)
		end
		table1[i] = table2
	end
	return table1
end
function modtable.GetInfo(id)
	local ud = {}
	ud.GetName = function()
		return game.Players:GetNameFromUserIdAsync(id)
	end
	ud.Id = id
	ud.GetAppearance = function()
		return game.Players:GetCharacterAppearanceAsync(id)
	end
	ud.GetGroups = function()
		return getgroups(id)
	end
	ud.GetPlayerThumbnail = function(Type,Size)
		return game.Players:GetUserThumbnailAsync(id,Type,Size)
	end
	ud.GetFriends = function()
		return getfriends(id)
	end
	ud.CheckIfOnline = function()
		return (httpserice:JSONDecode(httpserice:GetAsync("https://api.rprxy.xyz/users" ..id))).IsOnline
	end
	return ud
end
game.ReplicatedStorage.Events.Players.ChildAdded:Connect(function(obj)
	modtable[obj.Name] = {}
	modtable[obj.Name].Input = require(obj.Input)
	modtable[obj.Name].Info = modtable.GetInfo(game.Players:GetUserIdFromNameAsync(obj.Name))
	game.Players.PlayerRemoving:Connect(function(plr)
		if not obj then return end
		if plr.Name == obj.Name then
			obj:Remove()
		end
	end)
end)
return modtable

]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX98A253802EA945149F00D6B8543D7089">
					<Properties>
						<string name="Name">TempObjs</string>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX8BE119EFBEC64C3A91E77C87456A02EB">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Get</string>
						<string name="ScriptGuid">{315607ED-D8F6-4AD2-92B8-4E6ABB9AE510}</string>
						<ProtectedString name="Source"><![CDATA[Index = require(script.Index)
Indexenv = {}
envnum = 1
udnums = 0
Replace =  {}
Replace.Methods = {}
Replace.Methods.Instance = require(script.Methods.Instance)
Replace.Env = {}
Replace.Env.Condition = require(script.Env.Condition)
plrlib = require(script.Parent.PlayerLib)
function iscond(cond)
	for i,v in next, Replace.Env.Condition:GetConds() do
		if v == cond then
			return true
		end
	end
end
function unpack1(tab)
	if #tab == 0 then
		return nil
	end
	return unpack(tab)
end
function isenvwraped(env)
	for i,v in next, Indexenv do
		if env == v then
			return true
		end
	end
end
function envwrap(env)
	for i, v in next, env do
		env[i] = vwrap(v)
	end
	if env.workspace then
		env.workspace = vwrap(env.workspace)
	end
	if env.game then
		env.game = vwrap(env.game)
	end
	if env.script then
		env.script = vwrap(env.script)
	end
	if env.typeof then
		env.typeof = function(thing)
					if type(thing) == "userdata" and Index.getunwrapped(thing) then
						return typeof(Index.getunwrapped(thing))
					else
						return typeof(thing)
					end
		end
	end
	if env.type then
		env.type = function(thing)
					if type(thing) == "userdata" and Index.getunwrapped(thing) then
						return type(Index.getunwrapped(thing))
					else
						return type(thing)
					end
		end
	end
	if env.getmetatable then
		env.getmetatable = function(thing)
					if Index.getunwrapped(thing) then
						return getmetatable(Index.getunwrapped(thing))
					else
						return getmetatable(thing)
					end
		end
	end
	if env.require then
		env.require = function(th)
			if Index.getunwrapped(th) then
				th = Index.getunwrapped(th)
			end
			return vwrap(require(th))
		end
	end
	if env.setmetatable then
		env.setmetatable = function(thing1,thing2)
				if Index.getunwrapped(thing1) then
					return setmetatable(Index.getunwrapped(thing1),thing2)
				else
					return setmetatable(thing1,thing2)
				end
		end
	end
	local instnew = {}
	instnew.new = function(...) 
		local a = vunwrap({...})
		return (function(a,b,c)
		local obj = Instance.new(a,b)
		if c and type(c) == "table" then
			for i,v in next, c do
				obj[i] = v
			end
		end
		return obj
	end)(unpack1(a))
	end
	if env.Instance then
		env.Instance = vwrap(instnew)
	end
	for i,v in next, script.Env:GetChildren() do
		env[v.Name] = wrap(require(v))
	end
	env.sandbox_sand_val = true
	if not isenvwraped(env) then
		Indexenv[envnum] = env
	end
end
function vunwrap(val)
		val = val
		local typ = type(val)
		local typ2 = typeof(val)
		if val == nil then
			return nil
		elseif Index.getunwrapped(val) then
			local a = Index.getunwrapped(val)
			return a
		elseif typ == "table" then
			local tab2 = {}
			for i,v in next, val do
				tab2[i] = vunwrap(v)
			end
			return tab2
		elseif typ == "string" then
			local a = tostring(val)
			return a
		elseif typ == "number" then
			local a = tonumber(val)
			return a
		elseif type(val) == "bool" and val == false then
			return false
		elseif type(val) == "bool" and val == true then
			return true
		else 
			local a = val
			return val
		end
end
function vwrap(val)
	val = val
	local typ = type(val)
	local typ2 = typeof(val)
	if typ == "table" then
		local tab = {}
		for i,v in next, val do
			tab[i] = vwrap(val[i])
		end
		return tab
	elseif typ == "userdata" and typ2 == "Instance" then
		if Index.getunwrapped(val) then
			return val
		end
		return wrap(val)
	elseif typ == "function" then
		return function(...) local a = vunwrap({...}) return (function(...) local b = val(...) return vwrap(b) end)(unpack1(a)) end
	elseif typ2 == "userdata" and iscond(val) then
		if Index.getunwrapped(val) then
			return val
		end
		return wrap(val)
	else
		return val
	end
end
function wrap(ud)
	if Index.getunwrapped(ud) then
		return ud
	end
	local nud = newproxy(true)
	local meta = getmetatable(nud)
	local udnum = nil
	meta.__index = function(a,b)
		if b == "__SandboxId" then
			return udnum
		elseif b == "BreakJoints" and typeof(ud) == "Instance" and ud.ClassName == "Humanoid" then
			return function()
				if not ud.RootPart then return end
				local tab = {}
				local tab2 = {}
				local istracked = (function(val)
					for i,v in next, tab do
						if v == val then return true end
					end
				end)
				local istracked2 = (function(val)
					for i,v in next, tab2 do
						if v == val then return true end
					end
				end)
				local function track(obj)
					tab2[#tab2 + 1] = obj
					for i,v in next, obj:GetDescendants() do
						if v:IsA("JointInstance") and v.Part0 == obj and not istracked(v) then
							tab[#tab + 1] = v
							if v.Part1 and not istracked2(v.Part1) then
								track(v.Part1)
							end
						end
					end
				end
				track(ud.RootPart)
				for i,v in next, tab do
					v:Destroy()
				end
		end
		end
		if pcall(function() if not ud[b] then return error("Doesnt exist.") end return ud[b] end) then
			local val = ud[b]
			local typ = type(val)
			local typ2 = typeof(val)
			if typ == "userdata" and typ2 == "Instance" then
				return wrap(val)
			elseif typ == "function" then
				if pcall(function() return val() end) then
					if typeof(ud) ~= "userdata" then
						return (function(...) local a = vunwrap({...}) return (function(...) local b = ({val(...)}) b = vwrap(b) return unpack1(b)  end)(unpack1(a)) end)
					else
						return vwrap(val)
					end
				else
					if Replace.Methods[typeof(ud)] and Replace.Methods[typeof(ud)][b] then
						return (function(...) local a = vunwrap({...}) return (function(...) local c = ({Replace.Methods[typeof(ud)][b](...)}) c = vwrap(c) return unpack1(c) end)(ud,unpack1(a)) end)
					end
					if b == "FindFirstChildWhichIsA" then
						return nil
					elseif b == "FindFirstChildOfClass" then
						return nil
					elseif b == "FindFirstAncestorWhichIsA" then
						return nil
					elseif b == "FindFirstAncestorOfClass" then
						return nil
					end
					end
					return function(...) local a = vunwrap({...}) if a[1] ~= ud then return (function(...) local c = ({ud[b](...)}) c = vwrap(c) return unpack1(c) end)(ud,unpack1(a)) else return (function(...) local c = ud[b](...) return vwrap(c) end)(unpack1(a)) end end
			else
				if typeof(ud) == "Instance" and ud.ClassName == "Player" and plrlib[ud.Name][b] then
					return vwrap(plrlib[ud.Name][b])
				end
				if typeof(ud) == "Instance" and ud.ClassName == "Players" and b == "GetInfo" then
					return vwrap(plrlib.GetInfo)
				end
				return vwrap(val)
			end
			else
				if Replace.Methods[typeof(ud)] and Replace.Methods[typeof(ud)][b] then
					return (function(...) local a = vunwrap({...}) return (function(...) local c = ({Replace.Methods[typeof(ud)][b](...)}) c = vwrap(c) return unpack1(c) end)(ud,unpack1(a)) end)
				end
			end
		end
	
	meta.__newindex = function(a,b,c)
		local c = vunwrap(c)
		ud[b] = c
	end
	meta.__tostring = function(a)
		local th = vwrap(vunwrap(tostring(ud)))
		return th
	end
	meta.__tonumber = function(a)
		local th = vwrap(vunwrap(tonumber(ud)))
		return th
	end
	meta.__add = function(a,b)
		local th = vwrap(ud + vunwrap(b))
		return th
	end
	meta.__sub = function(a,b)
		local th = vwrap(ud - vunwrap(b))
		return th
	end
	meta.__mul = function(a,b)
		local th = vwrap(ud*vunwrap(b))
		return th
	end
	meta.__unm = function(a)
		local th = vwrap(vunwrap(-ud))
		return th
	end
	meta.__div = function(a,b)
		local th = vwrap(ud/vunwrap(b))
		return th
	end
	meta.__mod = function(a,b)
		local th = vwrap(ud%vunwrap(b))
		return th
	end
	meta.__pow = function(a,b)
		local th  = vwrap(ud^vunwrap(b))
		return th
	end
	meta.__eq = function(a,b)
		local th = vwrap((ud == vunwrap(b)))
		return th
	end
	meta.__it = function(a,b)
		local th = vwrap((ud < vunwrap(b)))
		return th
	end
	meta.__le = function(a,b)
		local th = vwrap((ud <= vunwrap(b)))
		return th
	end
	meta.__concact = function(a,b)
		local th = vwrap((ud ..vunwrap(b)))
		return th
	end
	meta.__call = function(a,...)
		local th = vwrap({ud(unpack1(vunwrap({...})))})
		return unpack1(th)
	end
	meta.__metatable = "sandboxed"
	meta.__len = function(a)
		local th = vwrap(vunwrap(#ud))
		return th
	end
	udnums = udnums + 1
	udnum = udnums
	Index.Tab[udnum] = ud
	return nud
	end
return function(env)
	local fenv = env or getfenv(2)
	local script2 = fenv.script
	envwrap(fenv)
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Configuration" referent="RBX18BE078CF40B4DA8809EFA749CD4626F">
						<Properties>
							<string name="Name">Env</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX205C9EA21BBD4D3795499FE95015F111">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Condition</string>
								<string name="ScriptGuid">{8EF6AB54-BBCD-4C12-94B0-138B546F1469}</string>
								<ProtectedString name="Source"><![CDATA[conds = {}
self = {}
function self:GetConds()
	local tab = {}
	for i,v in next, conds do
		tab[i] = v
	end
	return tab
end
function self.new(func)
	if type(func) ~= "function" then
		func = function() return true end
	end
	local np = newproxy(true)
	local meta = getmetatable(np)
	local tab = {}
	tab.Function = func
	function tab.Cast(...)
		if tab.Function(...) then
			return true
		else
			return false
		end
	end
	meta.__index = function(a,b)
		if tab[b] then
			return tab[b]
		end
	end
	meta.__newindex = function(a,b,c)
		if b == "Function" then
			tab[b] = c
		end
	end
	meta.__eq = function(a,b)
		return rawequal(np,b)
	end
	meta.__tostring = function()
		return tostring(tab.Cast())
	end
	meta.__metatable = "This metatable is locked."
	conds[#conds + 1] = np
	return np
end

return self
]]></ProtectedString>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX4331ADACD1084377B0C7CF355F14BC79">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Index</string>
							<string name="ScriptGuid">{54A48712-52F0-441B-B1F3-8547FE3CEAA5}</string>
							<ProtectedString name="Source"><![CDATA[local self = {}
self.Tab = {}
function self.getunwrapped(np)
	if pcall(function() return np.__SandboxId end) then
		return self.Tab[np.__SandboxId]
	end
end
return self
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Configuration" referent="RBXED378A4864F849B88E19C4B80D7F915D">
						<Properties>
							<string name="Name">Methods</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX7BAAB7A67FF74D7E817307883389A9EA">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Instance</string>
								<string name="ScriptGuid">{6B05F59E-55DE-4B2B-973D-F059F982143A}</string>
								<ProtectedString name="Source"><![CDATA[self = {}
local condlib = require(script.Parent.Parent.Env.Condition)
local index = require(script.Parent.Parent.Index)
local function iscond(cond)
	for i,v in next, condlib:GetConds() do
		if v == cond then
			return true
		end
	end
end
local function GetAncestors(obj)
	if obj.Parent then
		local a = obj.Parent
		local b = {}
		repeat
			b[#b + 1] = a
			a = a.Parent
		until a == nil
		return b
	end
end
function self:FindFirstChild(inst,thing)
	if index.getunwrapped(inst) then
		inst = index.getunwrapped(inst)
	end
	local children = inst:GetChildren()
	if thing == nil then
		return children[1]
	elseif iscond(thing) then
		for i,v in next, children do
			if thing.Cast(v) then
				return v
			end
		end
	elseif type(thing) == "string" then
		for i,v in next, children do
			if thing == (v.Name or tostring(v)) then
				return v
			end
		end
	elseif type(thing) == "number" then
		return children[thing]
	end
end
function self:FindFirstAncestor(inst,thing)
	if index.getunwrapped(inst) then
		inst = index.getunwrapped(inst)
	end
	local children = GetAncestors(inst)
	if thing == nil then
		return children[1]
	elseif iscond(thing) then
		for i,v in next, children do
			if thing.Cast(v) then
				return v
			end
		end
	elseif type(thing) == "string" then
		for i,v in next, children do
			if thing == (v.Name or tostring(v)) then
				return v
			end
		end
	elseif type(thing) == "number" then
		return children[thing]
	end
end
function self:FindFirstDescendant(inst,thing)
	if index.getunwrapped(inst) then
		inst = index.getunwrapped(inst)
	end
	local children = inst:GetDescendants()
	if thing == nil then
		return children[1]
	elseif iscond(thing) then
		for i,v in next, children do
			if thing.Cast(v) then
				return v
			end
		end
	elseif type(thing) == "string" then
		for i,v in next, children do
			if thing == (v.Name or tostring(v)) then
				return v
			end
		end
	elseif type(thing) == "number" then
		return children[thing]
	end
end
function self:GetChildren(inst,thing)
	if index.getunwrapped(inst) then
		inst = index.getunwrapped(inst)
	end
	local children = inst:GetChildren()
	if thing == nil then
		return children
	elseif iscond(thing) then
		local tab = {}
		for i,v in next, children do
			if thing.Cast(v) then
				tab[i] = v
			end
		end
		return tab
	elseif type(thing) == "string" then
		local tab = {}
		for i,v in next, children do
			if thing == (v.Name or tostring(v)) then
				tab[i] = v
			end
		end
		return tab
	elseif type(thing) == "number" then
		local tab = {}
		for i,v in next, children do
			if i < thing then
				tab[#tab + 1] = v
			end
		end
		return tab
	end
end
function self:GetAncestors(inst,thing)
	if index.getunwrapped(inst) then
		inst = index.getunwrapped(inst)
	end
	local children = GetAncestors(inst)
	if thing == nil then
		return children
	elseif iscond(thing) then
		local tab = {}
		for i,v in next, children do
			if thing.Cast(v) then
				tab[i] = v
			end
		end
		return tab
	elseif type(thing) == "string" then
		local tab = {}
		for i,v in next, children do
			if thing == (v.Name or tostring(v)) then
				tab[i] = v
			end
		end
		return tab
	elseif type(thing) == "number" then
		local tab = {}
		for i,v in next, children do
			if i < thing then
				tab[#tab + 1] = v
			end
		end
		return tab
	end
end
function self:GetDescendants(inst,thing)
	if index.getunwrapped(inst) then
		inst = index.getunwrapped(inst)
	end
	local children = inst:GetDescendants()
	if thing == nil then
		return children
	elseif iscond(thing) then
		local tab = {}
		for i,v in next, children do
			if thing.Cast(v) then
				tab[i] = v
			end
		end
		return tab
	elseif type(thing) == "string" then
		local tab = {}
		for i,v in next, children do
			if thing == (v.Name or tostring(v)) then
				tab[i] = v
			end
		end
		return tab
	elseif type(thing) == "number" then
		local tab = {}
		for i,v in next, children do
			if i < thing then
				tab[#tab + 1] = v
			end
		end
		return tab
	end
end
function self:WaitForChild(inst,thing,time1)
	if index.getunwrapped(inst) then
		inst = index.getunwrapped(inst)
	end
	local children = inst:GetChildren()
	if thing == nil and children[1] then
		return children[1]
	elseif iscond(thing) then
		for i,v in next, children do
			if thing.Cast(v) then
				return v
			end
		end
	elseif type(thing) == "string" then
		for i,v in next, children do
			if thing == (v.Name or tostring(v)) then
				return v
			end
		end
	elseif type(thing) == "number" and children[thing] then
		return children[thing]
	end
	local eve = Instance.new("BindableEvent",game.ServerScriptService.DirusEngine.TempObjs)
	local func1 = inst.ChildAdded:Connect(function(obj2)
		if thing == nil then
			eve:Fire(obj2)
			eve:Destroy()
		elseif iscond(thing) then
			if thing.Cast(obj2) then
				eve:Fire(obj2)
				eve:Destroy()
			end
		elseif type(thing) == "string" then
			if thing == (obj2.Name or tostring(obj2)) then
				eve:Fire(obj2)
				eve:Destroy()
			end
		elseif type(thing) == "number" then
			children = inst:GetChildren()
			if children[thing] then
				eve:Fire(obj2)
				eve:Destroy()
			end
		end
	end)
	local val = eve.Event:wait(time1)
	func1:disconnect()
	if eve then eve:Destroy() end
	return val
end
function self:WaitForDescendant(inst,thing,time1)
	if index.getunwrapped(inst) then
		inst = index.getunwrapped(inst)
	end
	local children = inst:GetDescendants()
	if thing == nil and children[1] then
		return children[1]
	elseif iscond(thing) then
		for i,v in next, children do
			if thing.Cast(v) then
				return v
			end
		end
	elseif type(thing) == "string" then
		for i,v in next, children do
			if thing == (v.Name or tostring(v)) then
				return v
			end
		end
	elseif type(thing) == "number" and children[thing] then
		return children[thing]
	end
	local eve = Instance.new("BindableEvent",game.ServerScriptService.DirusEngine.TempObjs)
	local func1 = inst.DescendantAdded:Connect(function(obj2)
		if thing == nil then
			eve:Fire(obj2)
			eve:Destroy()
		elseif iscond(thing) then
			if thing.Cast(obj2) then
				eve:Fire(obj2)
				eve:Destroy()
			end
		elseif type(thing) == "string" then
			if thing == (obj2.Name or tostring(obj2)) then
				eve:Fire(obj2)
				eve:Destroy()
			end
		elseif type(thing) == "number" then
			children = inst:GetDescendants()
			if children[thing] then
				eve:Fire(obj2)
				eve:Destroy()
			end
		end
	end)
	local val = eve.Event:wait(time1)
	func1:disconnect()
	if eve then eve:Destroy() end
	return val
end
function self:WaitForAncestor(inst,thing,time1)
	if index.getunwrapped(inst) then
		inst = index.getunwrapped(inst)
	end
	local children = GetAncestors(inst)
	if thing == nil and children[1] then
		return children[1]
	elseif iscond(thing) then
		for i,v in next, children do
			if thing.Cast(v) then
				return v
			end
		end
	elseif type(thing) == "string" then
		for i,v in next, children do
			if thing == (v.Name or tostring(v)) then
				return v
			end
		end
	elseif type(thing) == "number" and children[thing] then
		return children[thing]
	end
	local eve = Instance.new("BindableEvent",game.ServerScriptService.DirusEngine.TempObjs)
	local func1 = inst.DescendantAdded:Connect(function(obj2)
		if thing == nil then
			eve:Fire(obj2)
			eve:Destroy()
		elseif iscond(thing) then
			if thing.Cast(obj2) then
				eve:Fire(obj2)
				eve:Destroy()
			end
		elseif type(thing) == "string" then
			if thing == (obj2.Name or tostring(obj2)) then
				eve:Fire(obj2)
				eve:Destroy()
			end
		elseif type(thing) == "number" then
			children = GetAncestors(inst)
			if children[thing] then
				eve:Fire(obj2)
				eve:Destroy()
			end
		end
	end)
	local val = eve.Event:wait(time1)
	func1:disconnect()
	if eve then eve:Destroy() end
	return val
end

return self
]]></ProtectedString>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
			</Item>
		</Item>
	</Item>
</roblox>
