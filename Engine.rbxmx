<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<Meta name="ExplicitAutoJoints">true</Meta>
	<External>null</External>
	<External>nil</External>
	<Item class="Folder" referent="RBX782118663A7C47EFBA767DB8450EE873">
		<Properties>
			<string name="Name">Files</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Configuration" referent="RBXF36382E29DAF4900A28F69292A6EF049">
			<Properties>
				<string name="Name">StarterPlayer</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Configuration" referent="RBX516A6726BDCD4D1AA8D3904D6154529E">
				<Properties>
					<string name="Name">StarterPlayerScripts</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="LocalScript" referent="RBX8D69B15065F542798BF9BFE9AF5F4390">
					<Properties>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">PlrProbe</string>
						<string name="ScriptGuid">{363317DE-ADDF-4422-BDD6-F5C3C442D97D}</string>
						<ProtectedString name="Source"><![CDATA[joy1 = {}
joy1.Delta = Vector3.new(0,0,0)
joy1.Position = Vector3.new(0,0,0)
joy2 = {}
joy2.Delta = Vector3.new(0,0,0)
joy2.Position = Vector3.new(0,0,0)
plr = game.Players.LocalPlayer
mouse = plr:GetMouse()
camera = workspace.CurrentCamera
cc = game.ReplicatedStorage.Events.Players:WaitForChild(plr.Name)
idle = 0
uis = game:GetService("UserInputService")
uis.InputChanged:Connect(function(input,gp)
	if input.KeyCode == Enum.KeyCode.Thumbstick1 then
		joy1.Delta = input.Delta
		joy1.Position = input.Position
	elseif input.KeyCode == Enum.KeyCode.Thumbstick2 then
		joy2.Delta = input.Delta
		joy2.Position = input.Position
	end
end)
uis.InputBegan:Connect(function(input, gpe)
	cc.KeyDown:FireServer(input.KeyCode)
end)
uis.InputEnded:Connect(function(input, gpe)
	cc.KeyUp:FireServer(input.KeyCode)
end)

mouse.Button1Down:Connect(function() cc.b1d:FireServer() end)
mouse.Button1Up:Connect(function() cc.b1u:FireServer() end)
mouse.Button2Down:Connect(function() cc.b2d:FireServer() end)
mouse.Button2Up:Connect(function() cc.b2d:FireServer() end)
mouse.Move:Connect(function() idle = 1 end)
mouse.Idle:Connect(function() idle = 0 end)
plr.Chatted:Connect(function(msg) cc.Chat:FireServer(msg) end)
tabinput = {}
cc.changestate.OnClientEvent:Connect(function(hum,state,bool)
	hum:SetStateEnabled(state,bool)
end)
while wait(1/30) do
	local gui
	if uis:GetFocusedTextBox() then
		gui = true
	else
		gui = false
	end
	cc.joystick:FireServer(joy1,joy2)
	tabinput = {Accelerometer = uis.AccelerometerEnabled,Gamepad = uis.GamepadEnabled,Gyroscope = uis.GyroscopeEnabled,Keyboard = uis.KeyboardEnabled,Modal = uis.ModalEnabled,Mouse = uis.MouseEnabled,Touch = uis.TouchEnabled,VR = uis.VREnabled}
	cc.gui:FireServer(gui)
	cc.type:FireServer(tabinput)
	cc.Mouse:FireServer(mouse.hit, mouse.target, mouse.origin)
	if idle == 1 then
		cc.mMove:FireServer()
	else
		cc.mIdle:FireServer()
	end
	cc.Camera:FireServer(camera.CFrame)
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="Configuration" referent="RBX62540437F97D4419989AA6F80348D4E2">
			<Properties>
				<string name="Name">ReplicatedStorage</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Folder" referent="RBX0DF34ABCBE8A4FB1A42FFCB2BE32F39D">
				<Properties>
					<string name="Name">Events</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBX60F471F0DDC34812B64F2223C71C67C1">
					<Properties>
						<string name="Name">Players</string>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX2A6BCD6965FD4C0B9CFCFED06E98CC15">
				<Properties>
					<string name="Name">PlayerFold</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBXB56FE7527C334CA586D29074B02509C7">
					<Properties>
						<string name="Name">Folder</string>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="RemoteEvent" referent="RBXAEB626366EB3431383F5AB6EA22EB25F">
						<Properties>
							<string name="Name">Camera</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX03985BB446F94C8EA36F5934E1ECA3E2">
						<Properties>
							<string name="Name">Chat</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBXD3ED3873B49C44EAACFF164FC6E7AE17">
						<Properties>
							<string name="Name">KeyDown</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX5F8345683D3649069A846EDEBD97C753">
						<Properties>
							<string name="Name">KeyUp</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX1FCF6CAF5119423E84928CCEC3FFB4BA">
						<Properties>
							<string name="Name">Mouse</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX78B3AFE6EC7842609A88F4D93B07C9EA">
						<Properties>
							<string name="Name">b1d</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX7EDB8BE9DC904EDBA89364CBD41C3420">
						<Properties>
							<string name="Name">b1u</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBXFE9ED8A0871F4B2C994275D416841751">
						<Properties>
							<string name="Name">b2d</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX52285DA07C7546A7AF2F5F9B60AB13DC">
						<Properties>
							<string name="Name">b2u</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBXCA8CD36C1D1A46099447D38EF454841D">
						<Properties>
							<string name="Name">mIdle</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX879AAFBA448B4D0E9FFA3D9D7CB1C890">
						<Properties>
							<string name="Name">mMove</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXB51E57F10D8B4C44A4D039A2E1717C10">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Input</string>
							<string name="ScriptGuid">{136C0D38-AF84-4D3D-B718-5E031657CB94}</string>
							<ProtectedString name="Source"><![CDATA[modtable = {}
local cc = script.Parent
plr = game.Players[script.Parent.Name]
Mouse = {}
Mouse.hit = CFrame.new()
Mouse.target = nil
Mouse.origin = CFrame.new()
cc.Mouse.OnServerEvent:Connect(function(p, m1, m2, m3)
	if p ~= plr then return end
	modtable.MouseCframe = m1
	modtable.MouseTarget = m2
	modtable.MouseOrigin = m3
end)
local mkd = Instance.new("BindableEvent", cc)
local mku = Instance.new("BindableEvent", cc)
cc.KeyDown.OnServerEvent:Connect(function(p, k) if p ~= plr then return end mkd:Fire(k) end)
cc.KeyUp.OnServerEvent:Connect(function(p, k) if p ~= plr then return end mku:Fire(k) end)
modtable.KeyDown = mkd.Event
modtable.KeyUp = mku.Event
Button1Down = Instance.new("BindableEvent",cc)
Button1Up = Instance.new("BindableEvent",cc)
Button2Down = Instance.new("BindableEvent",cc)
Button2Up = Instance.new("BindableEvent",cc)
cc.b1d.OnServerEvent:Connect(function(p)
	if p ~= plr then return end
	Button1Down:Fire()
end)
cc.b1u.OnServerEvent:Connect(function(p)
	if p ~= plr then return end
	Button1Up:Fire()
end)
cc.b2d.OnServerEvent:Connect(function(p)
	if p ~= plr then return end
	Button2Down:Fire()
end)
cc.b2u.OnServerEvent:Connect(function(p)
	if p ~= plr then return end
	Button2Up:Fire()
end)
modtable.Button1Down = Button1Down.Event
modtable.Button1Up = Button1Up.Event
modtable.Button2Down = Button2Down.Event
modtable.Button2Up = Button2Up.Event

Camera = {}
modtable.CameraCframe = CFrame.new()
local mm = Instance.new("BindableEvent", cc)
local mi = Instance.new("BindableEvent", cc)
cc.Camera.OnServerEvent:Connect(function(p,val) if p ~= plr then return end modtable.CameraCframe = val end)
local ms = true
cc.mMove.OnServerEvent:Connect(function(p) if p ~= plr then return end ms = 1 end)
cc.mIdle.OnServerEvent:Connect(function(p) if p ~= plr then return end ms = 0 end)
local function mousem() 
	if ms == 1 then
		mm:Fire()
	elseif ms == 0 then
		mi:Fire()
	end
end
game:GetService('RunService').Heartbeat:Connect(mousem)
modtable.MouseMove = mm.Event
modtable.MouseIdle = mi.Event
local chat = Instance.new("BindableEvent", script)
cc.Chat.OnServerEvent:Connect(function(p, msg) if p ~= plr then return end chat:Fire(msg) end)
modtable.Chatted = chat.Event
modtable.Type = nil
modtable.IsInGui = false
cc.gui.OnServerEvent:Connect(function(p,gui)
	if p ~= plr then return end
	modtable.IsInGui = gui
end)
cc.type.OnServerEvent:Connect(function(p,type1)
	if p ~= plr then return end
	modtable.Type = type1
	for i,v in ipairs(type1) do
			print(v)
	end
end)
modtable.JoyStick1 = nil
modtable.JoyStick2 = nil
cc.joystick.OnServerEvent:Connect(function(p,joy1,joy2)
	if p ~= plr then return end
	modtable.JoyStick1 = joy1
	modtable.JoyStick2 = joy2
end)


return modtable

]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX77808C2A3D23479F9530B69670B9EA09">
						<Properties>
							<string name="Name">type</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX5B53E0C7FE5249DB9862102C07595CAA">
						<Properties>
							<string name="Name">gui</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX67D871E1A30E4F788448094CFC9A6AA4">
						<Properties>
							<string name="Name">joystick</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX9044DBFBA75B4E45A849E7D8FFA8613D">
						<Properties>
							<string name="Name">changestate</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
		</Item>
		<Item class="Configuration" referent="RBX1CC395104D3C44CA9721A70826D9B28C">
			<Properties>
				<string name="Name">ServerScriptService</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Script" referent="RBX9C9C233B0C4C49BAA98E952063E576E6">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">DirusEngine</string>
					<string name="ScriptGuid">{186C0D5F-9B63-45AF-A244-056E1A4BE7B4}</string>
					<ProtectedString name="Source"><![CDATA[game.Players.PlayerAdded:Connect(function(plr)
	local fold = game.ReplicatedStorage.PlayerFold.Folder:Clone()
	fold.Name = plr.Name
	fold.Parent = game.ReplicatedStorage.Events.Players
end)
function code() end
require(script.Get,getfenv(code))]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX564C601B768D436595609DB9877EC0F3">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Get</string>
						<string name="ScriptGuid">{28D1EF68-3DFB-45F5-94BF-82E3E608A231}</string>
						<ProtectedString name="Source"><![CDATA[Index = require(script.Index)
Indexenv = {}
envnum = 1
Replace =  {}
Replace.Methods = {}
Replace.Methods.Instance = require(script.Methods.Instance)
Replace.Env = {}
Replace.Env.Condition = require(script.Env.Condition)
plrlib = require(script.Parent.PlayerLib)
function iscond(cond)
	for i,v in next, Replace.Env.Condition:GetConds() do
		if v == cond then
			return true
		end
	end
end
function isenvwraped(env)
	for i,v in next, Indexenv do
		if env == v then
			return true
		end
	end
end
function envwrap(env)
	for i, v in next, env do
		env[i] = vwrap(v)
	end
	if env.workspace then
		env.workspace = vwrap(env.workspace)
	end
	if env.game then
		env.game = vwrap(env.game)
	end
	if env.script then
		env.script = vwrap(env.script)
	end
	if env.typeof then
		env.typeof = function(thing)
					if type(thing) == "userdata" and Index.getunwrapped(thing) then
						return typeof(Index.getunwrapped(thing))
					else
						return typeof(thing)
					end
		end
	end
	if env.type then
		env.type = function(thing)
					if type(thing) == "userdata" and Index.getunwrapped(thing) then
						return type(Index.getunwrapped(thing))
					else
						return type(thing)
					end
		end
	end
	if env.getmetatable then
		env.getmetatable = function(thing)
					if Index.getunwrapped(thing) then
						return getmetatable(Index.getunwrapped(thing))
					else
						return getmetatable(thing)
					end
		end
	end
	if env.setmetatable then
		env.setmetatable = function(thing1,thing2)
				if Index.getunwrapped(thing1) then
					return setmetatable(Index.getunwrapped(thing1),thing2)
				else
					return setmetatable(thing1,thing2)
				end
		end
	end
	for i,v in next, script.Env:GetChildren() do
		env[v.Name] = require(v)
	end
	if not isenvwraped(env) then
		Indexenv[envnum] = env
	end
end
function vunwrap(val)
		local typ = type(val)
		local typ2 = typeof(val)
		if typ == "table" then
			local tab2 = {}
			for i,v in next, val do
				tab2[i] = vunwrap(v)
			end
			return tab2
		elseif typ == "string" then
			local a = tostring(val)
			return a
		elseif typ == "number" then
			local a = tonumber(val)
			return a
		elseif typ == "userdata" and Index.getunwrapped(val) then
			local a = vunwrap(Index.getunwrapped(val))
			return a
		else
			return val
		end
end
function vwrap(val)
	local typ = type(val)
	local typ2 = typeof(val)
	if typ == "table" then
		local tab = {}
		for i,v in next, val do
			tab[i] = vwrap(val[i])
		end
		return tab
	elseif typ == "userdata" and typ2 == "Instance" then
		if Index.getunwrapped(val) then
			return val
		end
		return wrap(val)
	elseif typ == "function" then
		return function(...) local a = vunwrap({...}) return vwrap(val(a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8],a[9],a[10],a[11],a[12],a[13],a[14],a[15],a[16],a[17],a[18],a[19],a[20],a[21],a[22],a[23],a[24],a[25],a[26],a[27],a[28],a[29],a[30])) end
	elseif typ2 == "userdata" and iscond(val) then
		if Index.getunwrapped(val) then
			return val
		end
		return wrap(val)
	else
		return val
	end
end
function wrap(ud)
	if Index.getunwrapped(ud) then
		return ud
	end
	local nud = newproxy(true)
	local meta = getmetatable(nud)
	meta.__index = function(a,b)
		if pcall(function() if not ud[b] then return error("Doesnt exist.") end return ud[b] end) then
			local val = ud[b]
			local typ = type(val)
			local typ2 = typeof(val)
			if typ == "userdata" and typ2 == "Instance" then
				return wrap(val)
			elseif typ == "function" then
				if pcall(function() return val() end) then
					return vwrap(val)
				else
					if Replace.Methods[typeof(ud)] and Replace.Methods[typeof(ud)][b] then
						return function(...) return (function(ud,...) local a = {...} return vwrap(Replace.Methods[typeof(ud)][b](ud,a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8],a[9],a[10],a[11],a[12],a[13],a[14],a[15],a[16],a[17],a[18],a[19],a[20],a[21],a[22],a[23],a[24],a[25],a[26],a[27],a[28],a[29],a[30])) end) end
					end
					if b == "FindFirstChildWhichIsA" then
						return nil
					elseif b == "FindFirstChildOfClass" then
						return nil
					elseif b == "FindFirstAncestorWhichIsA" then
						return nil
					elseif b == "FindFirstAncestorOfClass" then
						return nil
					end
					end
					return function(...) local a = vunwrap({...})  return vwrap(ud[b](ud,a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8],a[9],a[10],a[11],a[12],a[13],a[14],a[15],a[16],a[17],a[18],a[19],a[20],a[21],a[22],a[23],a[24],a[25],a[26],a[27],a[28],a[29],a[30])) end
			else
				if typeof(ud) == "Instance" and ud.ClassName == "Player" and plrlib[ud.Name][b] then
					return vwrap(plrlib[ud.Name][b])
				end
				if typeof(ud) == "Instance" and ud.ClassName == "Players" and b == "GetInfo" then
					return vwrap(plrlib.GetInfo)
				end
				return vwrap(val)
			end
			else
			if Replace.Methods[typeof(ud)] and Replace.Methods[typeof(ud)][b] then
				return function(...) local a = vunwrap({...}) return vwrap(Replace.Methods[typeof(ud)][b](ud,a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8],a[9],a[10],a[11],a[12],a[13],a[14],a[15],a[16],a[17],a[18],a[19],a[20],a[21],a[22],a[23],a[24],a[25],a[26],a[27],a[28],a[29],a[30])) end
			end
			end
		end
	
	meta.__newindex = function(a,b,c)
		return (function()
			ud[b] = c
		end)()
	end
	meta.__tostring = function(a)
		return vwrap(tostring(ud))
	end
	meta.__tonumber = function(a)
		return vwrap(tonumber(ud))
	end
	meta.__add = function(a,b)
		return vwrap(ud + b)
	end
	meta.__sub = function(a,b)
		return vwrap(ud - b)
	end
	meta.__mul = function(a,b)
		return vwrap(ud*b)
	end
	meta.__unm = function(a)
		return vwrap(-ud)
	end
	meta.__div = function(a,b)
		return vwrap(ud/b)
	end
	meta.__mod = function(a,b)
		return vwrap(ud%b)
	end
	meta.__pow = function(a,b)
		return vwrap(ud^b)
	end
	meta.__eq = function(a,b)
		return vwrap((ud == b))
	end
	meta.__it = function(a,b)
		return vwrap((ud < b))
	end
	meta.__le = function(a,b)
		return vwrap((ud <= b))
	end
	meta.__concact = function(a,b)
		return vwrap((ud ..b))
	end
	meta.__call = function(a,...)
		return vwrap(ud(...))
	end
	meta.__metatable = "sandboxed"
	local numcheck = false
	for i,v in next, Index.One do
		if rawequal(v,ud) then
			Index.Two[i] = nud
			numcheck = true
		end
	end
	if not numcheck then
		Index.One[#Index.One + 1] = ud
		Index.Two[#Index.Two + 1] = nud
	end
	meta.__len = function(a)
		return vwrap(#ud)
	end
	return nud
	end
if not Index.One[1] then
	Index.One[1] = wrap(game)
end
return function(env)
	local fenv = env or getfenv(2)
	local script2 = fenv.script
	envwrap(fenv)
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Configuration" referent="RBX152B02ADCE924648A7073A5C6D0E2B93">
						<Properties>
							<string name="Name">Env</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX8E2038BD6511426DB6419FD9F6527E74">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Condition</string>
								<string name="ScriptGuid">{930F999F-C3CB-42F3-8087-E45A221B3AB8}</string>
								<ProtectedString name="Source"><![CDATA[conds = {}
self = {}
function self:GetConds()
	local tab = {}
	for i,v in next, conds do
		tab[i] = v
	end
	return tab
end
function self.new(func)
	if type(func) ~= "function" then
		func = function() return true end
	end
	local np = newproxy(true)
	local meta = getmetatable(np)
	local tab = {}
	tab.Function = func
	function tab.Cast(...)
		if tab.Function(...) then
			return true
		else
			return false
		end
	end
	meta.__index = function(a,b)
		if tab[b] then
			return tab[b]
		end
	end
	meta.__newindex = function(a,b,c)
		if b == "Function" then
			tab[b] = c
		end
	end
	meta.__eq = function(a,b)
		return rawequal(np,b)
	end
	meta.__tostring = function()
		return tostring(tab.Cast())
	end
	meta.__metatable = "This metatable is locked."
	conds[#conds + 1] = np
	return np
end

return self
]]></ProtectedString>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBXEB49EF8C47754819AF9FBC9B028E35D6">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Index</string>
							<string name="ScriptGuid">{413721B6-0592-41B3-B8C8-330198C7AA9E}</string>
							<ProtectedString name="Source"><![CDATA[local self = {}
self.One = {}
self.Two = {}
function self.getwrapped(inst)
	for i,v in next, self.One do
		if rawequal(v,inst) then
			return self.Two[i]
		end
	end
end
function self.getunwrapped(np)
	for i,v in next, self.Two do
		if rawequal(v,np) then
			return rawget(self.One,i)
		end
	end
end
return self
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Configuration" referent="RBX6A6D0FB46E8D4805A589C55E41BFF96C">
						<Properties>
							<string name="Name">Methods</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX332D40FEBF8D4651928E5E217AA3EF71">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Instance</string>
								<string name="ScriptGuid">{4054BB3C-D286-462D-B777-50714FBB9FA8}</string>
								<ProtectedString name="Source"><![CDATA[self = {}
local condlib = require(script.Parent.Parent.Env.Condition)
local index = require(script.Parent.Parent.Index)
local function iscond(cond)
	for i,v in next, condlib:GetConds() do
		if v == cond then
			return true
		end
	end
end
local function GetAncestors(obj)
	if obj.Parent then
		local a = obj.Parent
		local b = {}
		repeat
			b[#b + 1] = a
			a = a.Parent
		until a == nil
		return b
	end
end
function self:FindFirstChild(inst,thing)
	if index.getunwrapped(inst) then
		inst = index.getunwrapped(inst)
	end
	local children = inst:GetChildren()
	if thing == nil then
		print(children[1])
		return children[1]
	elseif iscond(thing) then
		for i,v in next, children do
			if thing.Cast(v) then
				print(v)
				return v
			end
		end
	elseif type(thing) == "string" then
		for i,v in next, children do
			if thing == (v.Name or tostring(v)) then
				return v
			end
		end
	elseif type(thing) == "number" then
		return children[thing]
	end
end
function self:FindFirstAncestor(inst,thing)
	if index.getunwrapped(inst) then
		inst = index.getunwrapped(inst)
	end
	local children = GetAncestors(inst)
	if thing == nil then
		return children[1]
	elseif iscond(thing) then
		for i,v in next, children do
			if thing.Cast(v) then
				return v
			end
		end
	elseif type(thing) == "string" then
		for i,v in next, children do
			if thing == (v.Name or tostring(v)) then
				return v
			end
		end
	elseif type(thing) == "number" then
		return children[thing]
	end
end
function self:FindFirstDescendant(inst,thing)
	if index.getunwrapped(inst) then
		inst = index.getunwrapped(inst)
	end
	local children = inst:GetDescendants()
	if thing == nil then
		return children[1]
	elseif iscond(thing) then
		for i,v in next, children do
			if thing.Cast(v) then
				return v
			end
		end
	elseif type(thing) == "string" then
		for i,v in next, children do
			if thing == (v.Name or tostring(v)) then
				return v
			end
		end
	elseif type(thing) == "number" then
		return children[thing]
	end
end
function self:GetChildren(inst,thing)
	if index.getunwrapped(inst) then
		inst = index.getunwrapped(inst)
	end
	local children = inst:GetChildren()
	if thing == nil then
		return children
	elseif iscond(thing) then
		local tab = {}
		for i,v in next, children do
			if thing.Cast(v) then
				tab[i] = v
			end
		end
		return tab
	elseif type(thing) == "string" then
		local tab = {}
		for i,v in next, children do
			if thing == (v.Name or tostring(v)) then
				tab[i] = v
			end
		end
		return tab
	elseif type(thing) == "number" then
		local tab = {}
		for i,v in next, children do
			if i < thing then
				tab[#tab + 1] = v
			end
		end
		return tab
	end
end
function self:GetAncestors(inst,thing)
	if index.getunwrapped(inst) then
		inst = index.getunwrapped(inst)
	end
	local children = GetAncestors(inst)
	if thing == nil then
		return children
	elseif iscond(thing) then
		local tab = {}
		for i,v in next, children do
			if thing.Cast(v) then
				tab[i] = v
			end
		end
		return tab
	elseif type(thing) == "string" then
		local tab = {}
		for i,v in next, children do
			if thing == (v.Name or tostring(v)) then
				tab[i] = v
			end
		end
		return tab
	elseif type(thing) == "number" then
		local tab = {}
		for i,v in next, children do
			if i < thing then
				tab[#tab + 1] = v
			end
		end
		return tab
	end
end
function self:GetDescendants(inst,thing)
	if index.getunwrapped(inst) then
		inst = index.getunwrapped(inst)
	end
	local children = inst:GetDescendants()
	if thing == nil then
		return children
	elseif iscond(thing) then
		local tab = {}
		for i,v in next, children do
			if thing.Cast(v) then
				tab[i] = v
			end
		end
		return tab
	elseif type(thing) == "string" then
		local tab = {}
		for i,v in next, children do
			if thing == (v.Name or tostring(v)) then
				tab[i] = v
			end
		end
		return tab
	elseif type(thing) == "number" then
		local tab = {}
		for i,v in next, children do
			if i < thing then
				tab[#tab + 1] = v
			end
		end
		return tab
	end
end
function self:WaitForChild(inst,thing,time1)
	if index.getunwrapped(inst) then
		inst = index.getunwrapped(inst)
	end
	local children = inst:GetChildren()
	if thing == nil and children[1] then
		return children[1]
	elseif iscond(thing) then
		for i,v in next, children do
			if thing.Cast(v) then
				return v
			end
		end
	elseif type(thing) == "string" then
		for i,v in next, children do
			if thing == (v.Name or tostring(v)) then
				return v
			end
		end
	elseif type(thing) == "number" and children[thing] then
		return children[thing]
	end
	local eve = Instance.new("BindableEvent",game.ServerScriptService.DirusEngine.TempObjs)
	local func1 = inst.ChildAdded:Connect(function(obj2)
		if thing == nil then
			eve:Fire(obj2)
			eve:Destroy()
		elseif iscond(thing) then
			if thing.Cast(obj2) then
				eve:Fire(obj2)
				eve:Destroy()
			end
		elseif type(thing) == "string" then
			if thing == (obj2.Name or tostring(obj2)) then
				eve:Fire(obj2)
				eve:Destroy()
			end
		elseif type(thing) == "number" then
			children = inst:GetChildren()
			if children[thing] then
				eve:Fire(obj2)
				eve:Destroy()
			end
		end
	end)
	local val = eve.Event:wait(time1)
	func1:disconnect()
	if eve then eve:Destroy() end
	return val
end
function self:WaitForDescendant(inst,thing,time1)
	if index.getunwrapped(inst) then
		inst = index.getunwrapped(inst)
	end
	local children = inst:GetDescendants()
	if thing == nil and children[1] then
		return children[1]
	elseif iscond(thing) then
		for i,v in next, children do
			if thing.Cast(v) then
				return v
			end
		end
	elseif type(thing) == "string" then
		for i,v in next, children do
			if thing == (v.Name or tostring(v)) then
				return v
			end
		end
	elseif type(thing) == "number" and children[thing] then
		return children[thing]
	end
	local eve = Instance.new("BindableEvent",game.ServerScriptService.DirusEngine.TempObjs)
	local func1 = inst.DescendantAdded:Connect(function(obj2)
		if thing == nil then
			eve:Fire(obj2)
			eve:Destroy()
		elseif iscond(thing) then
			if thing.Cast(obj2) then
				eve:Fire(obj2)
				eve:Destroy()
			end
		elseif type(thing) == "string" then
			if thing == (obj2.Name or tostring(obj2)) then
				eve:Fire(obj2)
				eve:Destroy()
			end
		elseif type(thing) == "number" then
			children = inst:GetDescendants()
			if children[thing] then
				eve:Fire(obj2)
				eve:Destroy()
			end
		end
	end)
	local val = eve.Event:wait(time1)
	func1:disconnect()
	if eve then eve:Destroy() end
	return val
end
function self:WaitForAncestor(inst,thing,time1)
	if index.getunwrapped(inst) then
		inst = index.getunwrapped(inst)
	end
	local children = GetAncestors(inst)
	if thing == nil and children[1] then
		return children[1]
	elseif iscond(thing) then
		for i,v in next, children do
			if thing.Cast(v) then
				return v
			end
		end
	elseif type(thing) == "string" then
		for i,v in next, children do
			if thing == (v.Name or tostring(v)) then
				return v
			end
		end
	elseif type(thing) == "number" and children[thing] then
		return children[thing]
	end
	local eve = Instance.new("BindableEvent",game.ServerScriptService.DirusEngine.TempObjs)
	local func1 = inst.DescendantAdded:Connect(function(obj2)
		if thing == nil then
			eve:Fire(obj2)
			eve:Destroy()
		elseif iscond(thing) then
			if thing.Cast(obj2) then
				eve:Fire(obj2)
				eve:Destroy()
			end
		elseif type(thing) == "string" then
			if thing == (obj2.Name or tostring(obj2)) then
				eve:Fire(obj2)
				eve:Destroy()
			end
		elseif type(thing) == "number" then
			children = GetAncestors(inst)
			if children[thing] then
				eve:Fire(obj2)
				eve:Destroy()
			end
		end
	end)
	local val = eve.Event:wait(time1)
	func1:disconnect()
	if eve then eve:Destroy() end
	return val
end

return self
]]></ProtectedString>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX429E055EA8474C0EA7D9C2821D45D9D3">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">PlayerLib</string>
						<string name="ScriptGuid">{81390C33-F754-469B-81FA-0619324A69CC}</string>
						<ProtectedString name="Source"><![CDATA[modtable = {}
groupservice = game:GetService("GroupService")
httpserice = game:GetService("HttpService")
function getwebdata(link)
	local tab = {}
	local num = 1
	repeat
		local json = httpserice:GetAsync(link .."?page=" ..num)
		for i, v in pairs(httpserice:JSONDecode(json)) do
			tab[#tab + 1] = modtable:GetInfo(v.Id)
		end
		num = num + 1
	until #(httpserice:JSONDecode(httpserice:GetAsync(link .."?page=" ..num))) == 0
	return tab
end
function getfriends(id)
	local page = game.Players:GetFriendsAsync(id)
	local table1 = {}
	local b = 0
	for i,v in pairs(getwebdata("https://api.rprxy.xyz/users/" ..id .."/friends")) do
		b = b + 1
		table1[b] = v
	end
	return table1
end
function getgroups(id)
	local table1 = {}
	local groups = groupservice:GetGroupsAsync(id)
	for i,group1 in ipairs(groups) do
		local group2 = groupservice:GetGroupInfoAsync(group1.Id)
		local table2 = {
			Name = group2.Name,
			Id = group2.Id,
			Emblem = group2.EmblemUrl,
			Description = group2.Description,
			Roles = group2.Roles,
			PlayerPrimary = group1.IsPrimary,
			PlayerClan = group1.IsInClan,
			PlayerRank = group1.Rank,
			PlayerRole = group1.Role,
		}
		if group2.Owner then
			table2.Owner = modtable:GetInfo(group2.Owner.Id)
		end
		table1[i] = table2
	end
	return table1
end
function modtable.GetInfo(id)
	local ud = {}
	ud.GetName = function()
		return game.Players:GetNameFromUserIdAsync(id)
	end
	ud.Id = id
	ud.GetAppearance = function()
		return game.Players:GetCharacterAppearanceAsync(id)
	end
	ud.GetGroups = function()
		return getgroups(id)
	end
	ud.GetPlayerThumbnail = function(Type,Size)
		return game.Players:GetUserThumbnailAsync(id,Type,Size)
	end
	ud.GetFriends = function()
		return getfriends(id)
	end
	ud.CheckIfOnline = function()
		return (httpserice:JSONDecode(httpserice:GetAsync("https://api.rprxy.xyz/users" ..id))).IsOnline
	end
	return ud
end
game.ReplicatedStorage.Events.Players.ChildAdded:Connect(function(obj)
	modtable[obj.Name] = {}
	modtable[obj.Name].Input = require(obj.Input)
	modtable[obj.Name].Info = modtable.GetInfo(game.Players:GetUserIdFromNameAsync(obj.Name))
	game.Players.PlayerRemoving:Connect(function(plr)
		if not obj then return end
		if plr.Name == obj.Name then
			obj:Remove()
		end
	end)
end)
return modtable

]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX6ABD2CD33D9F4D3F86550D37A62C2A9B">
					<Properties>
						<string name="Name">TempObjs</string>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
		</Item>
	</Item>
</roblox>
