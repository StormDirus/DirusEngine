<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<Meta name="ExplicitAutoJoints">true</Meta>
	<External>null</External>
	<External>nil</External>
	<Item class="Folder" referent="RBXA29147D244314B3CAC16824F2A3A05CC">
		<Properties>
			<string name="Name">Files</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Configuration" referent="RBX703A121298394AFE953226E3C847A987">
			<Properties>
				<string name="Name">StarterPlayer</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Configuration" referent="RBX90030F9D4EA74804815D2A7940CA914B">
				<Properties>
					<string name="Name">StarterPlayerScripts</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="LocalScript" referent="RBX72A39C7BD27C49E7851A9E736E2B560D">
					<Properties>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">PlrProbe</string>
						<string name="ScriptGuid">{363317DE-ADDF-4422-BDD6-F5C3C442D97D}</string>
						<ProtectedString name="Source"><![CDATA[joy1 = {}
joy1.Delta = Vector3.new(0,0,0)
joy1.Position = Vector3.new(0,0,0)
joy2 = {}
joy2.Delta = Vector3.new(0,0,0)
joy2.Position = Vector3.new(0,0,0)
plr = game.Players.LocalPlayer
mouse = plr:GetMouse()
camera = workspace.CurrentCamera
cc = game.ReplicatedStorage.Events.Players:WaitForChild(plr.Name)
idle = 0
uis = game:GetService("UserInputService")
uis.InputChanged:Connect(function(input,gp)
	if input.KeyCode == Enum.KeyCode.Thumbstick1 then
		joy1.Delta = input.Delta
		joy1.Position = input.Position
	elseif input.KeyCode == Enum.KeyCode.Thumbstick2 then
		joy2.Delta = input.Delta
		joy2.Position = input.Position
	end
end)
uis.InputBegan:Connect(function(input, gpe)
	cc.KeyDown:FireServer(input.KeyCode)
end)
uis.InputEnded:Connect(function(input, gpe)
	cc.KeyUp:FireServer(input.KeyCode)
end)

mouse.Button1Down:Connect(function() cc.b1d:FireServer() end)
mouse.Button1Up:Connect(function() cc.b1u:FireServer() end)
mouse.Button2Down:Connect(function() cc.b2d:FireServer() end)
mouse.Button2Up:Connect(function() cc.b2d:FireServer() end)
mouse.Move:Connect(function() idle = 1 end)
mouse.Idle:Connect(function() idle = 0 end)
plr.Chatted:Connect(function(msg) cc.Chat:FireServer(msg) end)
tabinput = {}
cc.changestate.OnClientEvent:Connect(function(hum,state,bool)
	hum:SetStateEnabled(state,bool)
end)
while wait(1/30) do
	local gui
	if uis:GetFocusedTextBox() then
		gui = true
	else
		gui = false
	end
	cc.joystick:FireServer(joy1,joy2)
	tabinput = {Accelerometer = uis.AccelerometerEnabled,Gamepad = uis.GamepadEnabled,Gyroscope = uis.GyroscopeEnabled,Keyboard = uis.KeyboardEnabled,Modal = uis.ModalEnabled,Mouse = uis.MouseEnabled,Touch = uis.TouchEnabled,VR = uis.VREnabled}
	cc.gui:FireServer(gui)
	cc.type:FireServer(tabinput)
	cc.Mouse:FireServer(mouse.hit, mouse.target, mouse.origin)
	if idle == 1 then
		cc.mMove:FireServer()
	else
		cc.mIdle:FireServer()
	end
	cc.Camera:FireServer(camera.CFrame)
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="Configuration" referent="RBX22DB264404E74328AE2F05683CDE348F">
			<Properties>
				<string name="Name">ReplicatedStorage</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Folder" referent="RBX7A33E31ED348465295FB907C8CE07BE6">
				<Properties>
					<string name="Name">Events</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBX13B1F4435D474D24868696F1CBA84003">
					<Properties>
						<string name="Name">Players</string>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXD1E3D23013D5460F9138D4D17F331B9A">
				<Properties>
					<string name="Name">PlayerFold</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBX3FA5014F4CDE4D3EA45EA7B1794CC918">
					<Properties>
						<string name="Name">Folder</string>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="RemoteEvent" referent="RBX446075AE8593407A8A56C75233679097">
						<Properties>
							<string name="Name">Camera</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX09FE799BAE984F7899FFF5EAB849B72B">
						<Properties>
							<string name="Name">Chat</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX133FD7ED310E421EBBF55E9FDB1D701F">
						<Properties>
							<string name="Name">KeyDown</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX7989FD6FF183424FBBEE8FB24A6FF10F">
						<Properties>
							<string name="Name">KeyUp</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX7ED98BAAB17A42E5863AEBD4B8DA2D3F">
						<Properties>
							<string name="Name">Mouse</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBXCB729EC4AA3B444185085F272DFB07B8">
						<Properties>
							<string name="Name">b1d</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX6F5D6AF5F48043238345A4B4F5573146">
						<Properties>
							<string name="Name">b1u</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX24885489779649CB86A8F12F07A97328">
						<Properties>
							<string name="Name">b2d</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX4EC07BCC033A4C4F9E550F238C41EB82">
						<Properties>
							<string name="Name">b2u</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBXAD5683D200A74D9896590C815777F958">
						<Properties>
							<string name="Name">mIdle</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBXEB5FAC69E7444CB0A37D42F77119E4E2">
						<Properties>
							<string name="Name">mMove</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX8DF5483B445D4CCE90B5CF5F3818655F">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Input</string>
							<string name="ScriptGuid">{136C0D38-AF84-4D3D-B718-5E031657CB94}</string>
							<ProtectedString name="Source"><![CDATA[modtable = {}
local cc = script.Parent
plr = game.Players[script.Parent.Name]
Mouse = {}
Mouse.hit = CFrame.new()
Mouse.target = nil
Mouse.origin = CFrame.new()
cc.Mouse.OnServerEvent:Connect(function(p, m1, m2, m3)
	if p ~= plr then return end
	modtable.MouseCframe = m1
	modtable.MouseTarget = m2
	modtable.MouseOrigin = m3
end)
local mkd = Instance.new("BindableEvent", cc)
local mku = Instance.new("BindableEvent", cc)
cc.KeyDown.OnServerEvent:Connect(function(p, k) if p ~= plr then return end mkd:Fire(k) end)
cc.KeyUp.OnServerEvent:Connect(function(p, k) if p ~= plr then return end mku:Fire(k) end)
modtable.KeyDown = mkd.Event
modtable.KeyUp = mku.Event
Button1Down = Instance.new("BindableEvent",cc)
Button1Up = Instance.new("BindableEvent",cc)
Button2Down = Instance.new("BindableEvent",cc)
Button2Up = Instance.new("BindableEvent",cc)
cc.b1d.OnServerEvent:Connect(function(p)
	if p ~= plr then return end
	Button1Down:Fire()
end)
cc.b1u.OnServerEvent:Connect(function(p)
	if p ~= plr then return end
	Button1Up:Fire()
end)
cc.b2d.OnServerEvent:Connect(function(p)
	if p ~= plr then return end
	Button2Down:Fire()
end)
cc.b2u.OnServerEvent:Connect(function(p)
	if p ~= plr then return end
	Button2Up:Fire()
end)
modtable.Button1Down = Button1Down.Event
modtable.Button1Up = Button1Up.Event
modtable.Button2Down = Button2Down.Event
modtable.Button2Up = Button2Up.Event

Camera = {}
modtable.CameraCframe = CFrame.new()
local mm = Instance.new("BindableEvent", cc)
local mi = Instance.new("BindableEvent", cc)
cc.Camera.OnServerEvent:Connect(function(p,val) if p ~= plr then return end modtable.CameraCframe = val end)
local ms = true
cc.mMove.OnServerEvent:Connect(function(p) if p ~= plr then return end ms = 1 end)
cc.mIdle.OnServerEvent:Connect(function(p) if p ~= plr then return end ms = 0 end)
local function mousem() 
	if ms == 1 then
		mm:Fire()
	elseif ms == 0 then
		mi:Fire()
	end
end
game:GetService('RunService').Heartbeat:Connect(mousem)
modtable.MouseMove = mm.Event
modtable.MouseIdle = mi.Event
local chat = Instance.new("BindableEvent", script)
cc.Chat.OnServerEvent:Connect(function(p, msg) if p ~= plr then return end chat:Fire(msg) end)
modtable.Chatted = chat.Event
modtable.Type = nil
modtable.IsInGui = false
cc.gui.OnServerEvent:Connect(function(p,gui)
	if p ~= plr then return end
	modtable.IsInGui = gui
end)
cc.type.OnServerEvent:Connect(function(p,type1)
	if p ~= plr then return end
	modtable.Type = type1
	for i,v in ipairs(type1) do
			print(v)
	end
end)
modtable.JoyStick1 = nil
modtable.JoyStick2 = nil
cc.joystick.OnServerEvent:Connect(function(p,joy1,joy2)
	if p ~= plr then return end
	modtable.JoyStick1 = joy1
	modtable.JoyStick2 = joy2
end)


return modtable

]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBXDF5A9D72122C45579C09ED7C3F3B9CD4">
						<Properties>
							<string name="Name">type</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX894D880E34EC4477A59C6FCDCD665867">
						<Properties>
							<string name="Name">gui</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBXC2446A2D43884426BCE122C1367E013F">
						<Properties>
							<string name="Name">joystick</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBXC2AF700FF8D74E509CCA6315EF1368E5">
						<Properties>
							<string name="Name">changestate</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
		</Item>
		<Item class="Configuration" referent="RBX17CAF34B2FB04DE2974E31875B3182F2">
			<Properties>
				<string name="Name">ServerScriptService</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Script" referent="RBXA428A06D44834F309F988F4F2AE5A08B">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">DirusEngine</string>
					<string name="ScriptGuid">{CA34BFA5-136B-484D-AA79-C7ED5D75F7A8}</string>
					<ProtectedString name="Source"><![CDATA[game.Players.PlayerAdded:Connect(function(plr)
	local fold = game.ReplicatedStorage.PlayerFold.Folder:Clone()
	fold.Name = plr.Name
	fold.Parent = game.ReplicatedStorage.Events.Players
end)
function code() end
require(script.Get,getfenv(code))]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX258DECA8846B4130AC00AB3196E93B1F">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Get</string>
						<string name="ScriptGuid">{AFB9AA51-86D1-4BEB-A78B-AF0873A4379D}</string>
						<ProtectedString name="Source"><![CDATA[Index = require(script.Index)
Indexenv = {}
envnum = 1
Replace =  {}
Replace.Methods = {}
Replace.Methods.Instance = require(script.Methods.Instance)
Replace.Env = {}
Replace.Env.Condition = require(script.Env.Condition)
plrlib = require(script.Parent.PlayerLib)
function iscond(cond)
	for i,v in next, Replace.Env.Condition:GetConds() do
		if v == cond then
			return true
		end
	end
end
function isenvwraped(env)
	for i,v in next, Indexenv do
		if env == v then
			return true
		end
	end
end
function envwrap(env)
	for i, v in next, env do
		env[i] = vwrap(v)
	end
	if env.workspace then
		env.workspace = vwrap(env.workspace)
	end
	if env.game then
		env.game = vwrap(env.game)
	end
	if env.script then
		env.script = vwrap(env.script)
	end
	if env.typeof then
		env.typeof = function(thing)
					if type(thing) == "userdata" and Index.getunwrapped(thing) then
						return typeof(Index.getunwrapped(thing))
					else
						return typeof(thing)
					end
		end
	end
	if env.type then
		env.type = function(thing)
					if type(thing) == "userdata" and Index.getunwrapped(thing) then
						return type(Index.getunwrapped(thing))
					else
						return type(thing)
					end
		end
	end
	if env.getmetatable then
		env.getmetatable = function(thing)
					if Index.getunwrapped(thing) then
						return getmetatable(Index.getunwrapped(thing))
					else
						return getmetatable(thing)
					end
		end
	end
	if env.setmetatable then
		env.setmetatable = function(thing1,thing2)
				if Index.getunwrapped(thing1) then
					return setmetatable(Index.getunwrapped(thing1),thing2)
				else
					return setmetatable(thing1,thing2)
				end
		end
	end
	for i,v in next, script.Env:GetChildren() do
		env[v.Name] = require(v)
	end
	if not isenvwraped(env) then
		Indexenv[envnum] = env
	end
end
function vunwrap(val)
		val = val
		local typ = type(val)
		local typ2 = typeof(val)
		if typ == "table" then
			local tab2 = {}
			for i,v in next, val do
				tab2[i] = vunwrap(v)
			end
			return tab2
		elseif typ == "string" then
			local a = tostring(val)
			return a
		elseif typ == "number" then
			local a = tonumber(val)
			return a
		elseif Index.getunwrapped(val) then
			local a = Index.getunwrapped(val)
			return a
		elseif val == false then
			return false
		elseif val == nil then
			return nil
		elseif val == true then
			return true
		else
			return val
		end
end
function vwrap(val)
	val = val
	local typ = type(val)
	local typ2 = typeof(val)
	if typ == "table" then
		local tab = {}
		for i,v in next, val do
			tab[i] = vwrap(val[i])
		end
		return tab
	elseif typ == "userdata" and typ2 == "Instance" then
		if Index.getunwrapped(val) then
			return val
		end
		return wrap(val)
	elseif typ == "function" then
		return function(...) local a = vunwrap({...}) return vwrap(val(a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8],a[9],a[10],a[11],a[12],a[13],a[14],a[15],a[16],a[17],a[18],a[19],a[20],a[21],a[22],a[23],a[24],a[25],a[26],a[27],a[28],a[29],a[30])) end
	elseif typ2 == "userdata" and iscond(val) then
		if Index.getunwrapped(val) then
			return val
		end
		return wrap(val)
	elseif typ == "string" then
		local a = tostring(val)
		return a
	elseif typ == "number" then
		local a = tonumber(val)
		return a
	elseif val == false then
		return false
	elseif val == nil then
		return nil
	elseif val == true then
		return true
	else
		return val
	end
end
function wrap(ud)
	if Index.getunwrapped(ud) then
		return ud
	end
	local nud = newproxy(true)
	local meta = getmetatable(nud)
	meta.__index = function(a,b)
		if pcall(function() if not ud[b] then return error("Doesnt exist.") end return ud[b] end) then
			local val = ud[b]
			local typ = type(val)
			local typ2 = typeof(val)
			if typ == "userdata" and typ2 == "Instance" then
				return wrap(val)
			elseif typ == "function" then
				if pcall(function() return val() end) then
					return vwrap(val)
				else
					if Replace.Methods[typeof(ud)] and Replace.Methods[typeof(ud)][b] then
						return (function(...) local a = vunwrap({...}) return vwrap(Replace.Methods[typeof(ud)][b](ud,a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8],a[9],a[10],a[11],a[12],a[13],a[14],a[15],a[16],a[17],a[18],a[19],a[20],a[21],a[22],a[23],a[24],a[25],a[26],a[27],a[28],a[29],a[30])) end)
					end
					if b == "FindFirstChildWhichIsA" then
						return nil
					elseif b == "FindFirstChildOfClass" then
						return nil
					elseif b == "FindFirstAncestorWhichIsA" then
						return nil
					elseif b == "FindFirstAncestorOfClass" then
						return nil
					end
					end
					return function(...) local a = vunwrap({...}) for i,v in next, a do print(b ..tostring(i) .." " ..tostring(v.ClassName)) end return vwrap(ud[b](ud,a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8],a[9],a[10],a[11],a[12],a[13],a[14],a[15],a[16],a[17],a[18],a[19],a[20],a[21],a[22],a[23],a[24],a[25],a[26],a[27],a[28],a[29],a[30])) end
			else
				if typeof(ud) == "Instance" and ud.ClassName == "Player" and plrlib[ud.Name][b] then
					return vwrap(plrlib[ud.Name][b])
				end
				if typeof(ud) == "Instance" and ud.ClassName == "Players" and b == "GetInfo" then
					return vwrap(plrlib.GetInfo)
				end
				return vwrap(val)
			end
			else
			if Replace.Methods[typeof(ud)] and Replace.Methods[typeof(ud)][b] then
				return function(...) local a = vunwrap({...}) return vwrap(Replace.Methods[typeof(ud)][b](ud,a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8],a[9],a[10],a[11],a[12],a[13],a[14],a[15],a[16],a[17],a[18],a[19],a[20],a[21],a[22],a[23],a[24],a[25],a[26],a[27],a[28],a[29],a[30]))(...) end
			end
			end
		end
	
	meta.__newindex = function(a,b,c)
		return (function()
			local c = vunwrap(c)
			ud[b] = c
		end)()
	end
	meta.__tostring = function(a)
		local th = vwrap(tostring(ud))
		return th
	end
	meta.__tonumber = function(a)
		local th = vwrap(tonumber(ud))
		return th
	end
	meta.__add = function(a,b)
		local th = vwrap(ud + b)
		return th
	end
	meta.__sub = function(a,b)
		local th = vwrap(ud - b)
		return th
	end
	meta.__mul = function(a,b)
		local th = vwrap(ud*b)
		return th
	end
	meta.__unm = function(a)
		local th = vwrap(-ud)
		return th
	end
	meta.__div = function(a,b)
		local th = vwrap(ud/b)
		return th
	end
	meta.__mod = function(a,b)
		local th = vwrap(ud%b)
		return th
	end
	meta.__pow = function(a,b)
		local th  = vwrap(ud^b)
		return th
	end
	meta.__eq = function(a,b)
		local th = vwrap((ud == b))
		return th
	end
	meta.__it = function(a,b)
		local th = vwrap((ud < b))
		return th
	end
	meta.__le = function(a,b)
		local th = vwrap((ud <= b))
		return th
	end
	meta.__concact = function(a,b)
		local th = vwrap((ud ..b))
		return th
	end
	meta.__call = function(a,...)
		local th = vwrap(ud(...))
		return th
	end
	meta.__metatable = "sandboxed"
	local numcheck = false
	for i,v in next, Index.One do
		if rawequal(v,ud) then
			Index.Two[i] = nud
			numcheck = true
		end
	end
	if not numcheck then
		Index.One[#Index.One + 1] = ud
		Index.Two[#Index.Two + 1] = nud
	end
	meta.__len = function(a)
		local th = vwrap(#ud)
		return th
	end
	return nud
	end
if not Index.One[1] then
	Index.One[1] = wrap(game)
end
return function(env)
	local fenv = env or getfenv(2)
	local script2 = fenv.script
	envwrap(fenv)
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Configuration" referent="RBXAF8DA7DF49774C12B601FD48FC65925B">
						<Properties>
							<string name="Name">Env</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX24A0CA3438574BD89A19C818DBB01BF1">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Condition</string>
								<string name="ScriptGuid">{3A42DAA9-77FA-4094-85A0-14541492BFCB}</string>
								<ProtectedString name="Source"><![CDATA[conds = {}
self = {}
function self:GetConds()
	local tab = {}
	for i,v in next, conds do
		tab[i] = v
	end
	return tab
end
function self.new(func)
	if type(func) ~= "function" then
		func = function() return true end
	end
	local np = newproxy(true)
	local meta = getmetatable(np)
	local tab = {}
	tab.Function = func
	function tab.Cast(...)
		if tab.Function(...) then
			return true
		else
			return false
		end
	end
	meta.__index = function(a,b)
		if tab[b] then
			return tab[b]
		end
	end
	meta.__newindex = function(a,b,c)
		if b == "Function" then
			tab[b] = c
		end
	end
	meta.__eq = function(a,b)
		return rawequal(np,b)
	end
	meta.__tostring = function()
		return tostring(tab.Cast())
	end
	meta.__metatable = "This metatable is locked."
	conds[#conds + 1] = np
	return np
end

return self
]]></ProtectedString>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBXB41538516BB04AC29E1CBAA3764CE509">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Index</string>
							<string name="ScriptGuid">{8D877903-F2A8-4B25-BFD8-7A23479AFC0D}</string>
							<ProtectedString name="Source"><![CDATA[local self = {}
self.One = {}
self.Two = {}
function self.getwrapped(inst)
	for i,v in next, self.One do
		if rawequal(v,inst) then
			return self.Two[i]
		end
	end
end
function self.getunwrapped(np)
	for i,v in next, self.Two do
		if rawequal(v,np) then
			return rawget(self.One,i)
		end
	end
end
return self
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Configuration" referent="RBX8A625178F5FD4871A14DEB9D2A2BBE6D">
						<Properties>
							<string name="Name">Methods</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXD33C5BBB775143BCB1521293AF7F1D7C">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Instance</string>
								<string name="ScriptGuid">{AD9027CA-68C6-4510-BEB8-FC0DC7BCCC72}</string>
								<ProtectedString name="Source"><![CDATA[self = {}
local condlib = require(script.Parent.Parent.Env.Condition)
local index = require(script.Parent.Parent.Index)
local function iscond(cond)
	for i,v in next, condlib:GetConds() do
		if v == cond then
			return true
		end
	end
end
local function GetAncestors(obj)
	if obj.Parent then
		local a = obj.Parent
		local b = {}
		repeat
			b[#b + 1] = a
			a = a.Parent
		until a == nil
		return b
	end
end
function self:FindFirstChild(inst,thing)
	if index.getunwrapped(inst) then
		inst = index.getunwrapped(inst)
	end
	local children = inst:GetChildren()
	if thing == nil then
		return children[1]
	elseif iscond(thing) then
		for i,v in next, children do
			if thing.Cast(v) then
				print(v)
				return v
			end
		end
	elseif type(thing) == "string" then
		for i,v in next, children do
			if thing == (v.Name or tostring(v)) then
				return v
			end
		end
	elseif type(thing) == "number" then
		return children[thing]
	end
end
function self:FindFirstAncestor(inst,thing)
	if index.getunwrapped(inst) then
		inst = index.getunwrapped(inst)
	end
	local children = GetAncestors(inst)
	if thing == nil then
		return children[1]
	elseif iscond(thing) then
		for i,v in next, children do
			if thing.Cast(v) then
				return v
			end
		end
	elseif type(thing) == "string" then
		for i,v in next, children do
			if thing == (v.Name or tostring(v)) then
				return v
			end
		end
	elseif type(thing) == "number" then
		return children[thing]
	end
end
function self:FindFirstDescendant(inst,thing)
	if index.getunwrapped(inst) then
		inst = index.getunwrapped(inst)
	end
	local children = inst:GetDescendants()
	if thing == nil then
		return children[1]
	elseif iscond(thing) then
		for i,v in next, children do
			if thing.Cast(v) then
				return v
			end
		end
	elseif type(thing) == "string" then
		for i,v in next, children do
			if thing == (v.Name or tostring(v)) then
				return v
			end
		end
	elseif type(thing) == "number" then
		return children[thing]
	end
end
function self:GetChildren(inst,thing)
	if index.getunwrapped(inst) then
		inst = index.getunwrapped(inst)
	end
	local children = inst:GetChildren()
	if thing == nil then
		return children
	elseif iscond(thing) then
		local tab = {}
		for i,v in next, children do
			if thing.Cast(v) then
				tab[i] = v
			end
		end
		return tab
	elseif type(thing) == "string" then
		local tab = {}
		for i,v in next, children do
			if thing == (v.Name or tostring(v)) then
				tab[i] = v
			end
		end
		return tab
	elseif type(thing) == "number" then
		local tab = {}
		for i,v in next, children do
			if i < thing then
				tab[#tab + 1] = v
			end
		end
		return tab
	end
end
function self:GetAncestors(inst,thing)
	if index.getunwrapped(inst) then
		inst = index.getunwrapped(inst)
	end
	local children = GetAncestors(inst)
	if thing == nil then
		return children
	elseif iscond(thing) then
		local tab = {}
		for i,v in next, children do
			if thing.Cast(v) then
				tab[i] = v
			end
		end
		return tab
	elseif type(thing) == "string" then
		local tab = {}
		for i,v in next, children do
			if thing == (v.Name or tostring(v)) then
				tab[i] = v
			end
		end
		return tab
	elseif type(thing) == "number" then
		local tab = {}
		for i,v in next, children do
			if i < thing then
				tab[#tab + 1] = v
			end
		end
		return tab
	end
end
function self:GetDescendants(inst,thing)
	if index.getunwrapped(inst) then
		inst = index.getunwrapped(inst)
	end
	local children = inst:GetDescendants()
	if thing == nil then
		return children
	elseif iscond(thing) then
		local tab = {}
		for i,v in next, children do
			if thing.Cast(v) then
				tab[i] = v
			end
		end
		return tab
	elseif type(thing) == "string" then
		local tab = {}
		for i,v in next, children do
			if thing == (v.Name or tostring(v)) then
				tab[i] = v
			end
		end
		return tab
	elseif type(thing) == "number" then
		local tab = {}
		for i,v in next, children do
			if i < thing then
				tab[#tab + 1] = v
			end
		end
		return tab
	end
end
function self:WaitForChild(inst,thing,time1)
	if index.getunwrapped(inst) then
		inst = index.getunwrapped(inst)
	end
	local children = inst:GetChildren()
	if thing == nil and children[1] then
		return children[1]
	elseif iscond(thing) then
		for i,v in next, children do
			if thing.Cast(v) then
				return v
			end
		end
	elseif type(thing) == "string" then
		for i,v in next, children do
			if thing == (v.Name or tostring(v)) then
				return v
			end
		end
	elseif type(thing) == "number" and children[thing] then
		return children[thing]
	end
	local eve = Instance.new("BindableEvent",game.ServerScriptService.DirusEngine.TempObjs)
	local func1 = inst.ChildAdded:Connect(function(obj2)
		if thing == nil then
			eve:Fire(obj2)
			eve:Destroy()
		elseif iscond(thing) then
			if thing.Cast(obj2) then
				eve:Fire(obj2)
				eve:Destroy()
			end
		elseif type(thing) == "string" then
			if thing == (obj2.Name or tostring(obj2)) then
				eve:Fire(obj2)
				eve:Destroy()
			end
		elseif type(thing) == "number" then
			children = inst:GetChildren()
			if children[thing] then
				eve:Fire(obj2)
				eve:Destroy()
			end
		end
	end)
	local val = eve.Event:wait(time1)
	func1:disconnect()
	if eve then eve:Destroy() end
	return val
end
function self:WaitForDescendant(inst,thing,time1)
	if index.getunwrapped(inst) then
		inst = index.getunwrapped(inst)
	end
	local children = inst:GetDescendants()
	if thing == nil and children[1] then
		return children[1]
	elseif iscond(thing) then
		for i,v in next, children do
			if thing.Cast(v) then
				return v
			end
		end
	elseif type(thing) == "string" then
		for i,v in next, children do
			if thing == (v.Name or tostring(v)) then
				return v
			end
		end
	elseif type(thing) == "number" and children[thing] then
		return children[thing]
	end
	local eve = Instance.new("BindableEvent",game.ServerScriptService.DirusEngine.TempObjs)
	local func1 = inst.DescendantAdded:Connect(function(obj2)
		if thing == nil then
			eve:Fire(obj2)
			eve:Destroy()
		elseif iscond(thing) then
			if thing.Cast(obj2) then
				eve:Fire(obj2)
				eve:Destroy()
			end
		elseif type(thing) == "string" then
			if thing == (obj2.Name or tostring(obj2)) then
				eve:Fire(obj2)
				eve:Destroy()
			end
		elseif type(thing) == "number" then
			children = inst:GetDescendants()
			if children[thing] then
				eve:Fire(obj2)
				eve:Destroy()
			end
		end
	end)
	local val = eve.Event:wait(time1)
	func1:disconnect()
	if eve then eve:Destroy() end
	return val
end
function self:WaitForAncestor(inst,thing,time1)
	if index.getunwrapped(inst) then
		inst = index.getunwrapped(inst)
	end
	local children = GetAncestors(inst)
	if thing == nil and children[1] then
		return children[1]
	elseif iscond(thing) then
		for i,v in next, children do
			if thing.Cast(v) then
				return v
			end
		end
	elseif type(thing) == "string" then
		for i,v in next, children do
			if thing == (v.Name or tostring(v)) then
				return v
			end
		end
	elseif type(thing) == "number" and children[thing] then
		return children[thing]
	end
	local eve = Instance.new("BindableEvent",game.ServerScriptService.DirusEngine.TempObjs)
	local func1 = inst.DescendantAdded:Connect(function(obj2)
		if thing == nil then
			eve:Fire(obj2)
			eve:Destroy()
		elseif iscond(thing) then
			if thing.Cast(obj2) then
				eve:Fire(obj2)
				eve:Destroy()
			end
		elseif type(thing) == "string" then
			if thing == (obj2.Name or tostring(obj2)) then
				eve:Fire(obj2)
				eve:Destroy()
			end
		elseif type(thing) == "number" then
			children = GetAncestors(inst)
			if children[thing] then
				eve:Fire(obj2)
				eve:Destroy()
			end
		end
	end)
	local val = eve.Event:wait(time1)
	func1:disconnect()
	if eve then eve:Destroy() end
	return val
end

return self
]]></ProtectedString>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBXB07D734E6BA840D2A65ACA41AE0CBA48">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">PlayerLib</string>
						<string name="ScriptGuid">{1441CA58-A248-4222-A136-9EE38DE9F65D}</string>
						<ProtectedString name="Source"><![CDATA[modtable = {}
groupservice = game:GetService("GroupService")
httpserice = game:GetService("HttpService")
function getwebdata(link)
	local tab = {}
	local num = 1
	repeat
		local json = httpserice:GetAsync(link .."?page=" ..num)
		for i, v in pairs(httpserice:JSONDecode(json)) do
			tab[#tab + 1] = modtable:GetInfo(v.Id)
		end
		num = num + 1
	until #(httpserice:JSONDecode(httpserice:GetAsync(link .."?page=" ..num))) == 0
	return tab
end
function getfriends(id)
	local page = game.Players:GetFriendsAsync(id)
	local table1 = {}
	local b = 0
	for i,v in pairs(getwebdata("https://api.rprxy.xyz/users/" ..id .."/friends")) do
		b = b + 1
		table1[b] = v
	end
	return table1
end
function getgroups(id)
	local table1 = {}
	local groups = groupservice:GetGroupsAsync(id)
	for i,group1 in ipairs(groups) do
		local group2 = groupservice:GetGroupInfoAsync(group1.Id)
		local table2 = {
			Name = group2.Name,
			Id = group2.Id,
			Emblem = group2.EmblemUrl,
			Description = group2.Description,
			Roles = group2.Roles,
			PlayerPrimary = group1.IsPrimary,
			PlayerClan = group1.IsInClan,
			PlayerRank = group1.Rank,
			PlayerRole = group1.Role,
		}
		if group2.Owner then
			table2.Owner = modtable:GetInfo(group2.Owner.Id)
		end
		table1[i] = table2
	end
	return table1
end
function modtable.GetInfo(id)
	local ud = {}
	ud.GetName = function()
		return game.Players:GetNameFromUserIdAsync(id)
	end
	ud.Id = id
	ud.GetAppearance = function()
		return game.Players:GetCharacterAppearanceAsync(id)
	end
	ud.GetGroups = function()
		return getgroups(id)
	end
	ud.GetPlayerThumbnail = function(Type,Size)
		return game.Players:GetUserThumbnailAsync(id,Type,Size)
	end
	ud.GetFriends = function()
		return getfriends(id)
	end
	ud.CheckIfOnline = function()
		return (httpserice:JSONDecode(httpserice:GetAsync("https://api.rprxy.xyz/users" ..id))).IsOnline
	end
	return ud
end
game.ReplicatedStorage.Events.Players.ChildAdded:Connect(function(obj)
	modtable[obj.Name] = {}
	modtable[obj.Name].Input = require(obj.Input)
	modtable[obj.Name].Info = modtable.GetInfo(game.Players:GetUserIdFromNameAsync(obj.Name))
	game.Players.PlayerRemoving:Connect(function(plr)
		if not obj then return end
		if plr.Name == obj.Name then
			obj:Remove()
		end
	end)
end)
return modtable

]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX2B65DEAF7D9C4F5CB5A81B40DA25600C">
					<Properties>
						<string name="Name">TempObjs</string>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
		</Item>
	</Item>
</roblox>
