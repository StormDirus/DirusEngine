<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<Meta name="ExplicitAutoJoints">true</Meta>
	<External>null</External>
	<External>nil</External>
	<Item class="Folder" referent="RBX79FAE4328ACC4EF1B332894CA928A594">
		<Properties>
			<string name="Name">Files</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Configuration" referent="RBX602325F9AB8446A584FF15CCB9AC1C1B">
			<Properties>
				<string name="Name">StarterPlayer</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Configuration" referent="RBXB3BDDEE0AF134E1EA16E5C45CF6AFE8D">
				<Properties>
					<string name="Name">StarterPlayerScripts</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="LocalScript" referent="RBXCB207684D4894FA6AB50B2B6F52CEAA4">
					<Properties>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">PlrProbe</string>
						<string name="ScriptGuid">{E9CC71A3-6ADF-423E-B16E-D792BEE60BC1}</string>
						<ProtectedString name="Source"><![CDATA[joy1 = {}
joy1.Delta = Vector3.new(0,0,0)
joy1.Position = Vector3.new(0,0,0)
joy2 = {}
joy2.Delta = Vector3.new(0,0,0)
joy2.Position = Vector3.new(0,0,0)
plr = game.Players.LocalPlayer
mouse = plr:GetMouse()
camera = workspace.CurrentCamera
cc = game.ReplicatedStorage.Events.Players:WaitForChild(plr.Name)
idle = 0
uis = game:GetService("UserInputService")
uis.InputChanged:Connect(function(input,gp)
	if input.KeyCode == Enum.KeyCode.Thumbstick1 then
		joy1.Delta = input.Delta
		joy1.Position = input.Position
	elseif input.KeyCode == Enum.KeyCode.Thumbstick2 then
		joy2.Delta = input.Delta
		joy2.Position = input.Position
	end
end)
uis.InputBegan:Connect(function(input, gpe)
	cc.KeyDown:FireServer(input.KeyCode)
end)
uis.InputEnded:Connect(function(input, gpe)
	cc.KeyUp:FireServer(input.KeyCode)
end)

mouse.Button1Down:Connect(function() cc.b1d:FireServer() end)
mouse.Button1Up:Connect(function() cc.b1u:FireServer() end)
mouse.Button2Down:Connect(function() cc.b2d:FireServer() end)
mouse.Button2Up:Connect(function() cc.b2d:FireServer() end)
mouse.Move:Connect(function() idle = 1 end)
mouse.Idle:Connect(function() idle = 0 end)
plr.Chatted:Connect(function(msg) cc.Chat:FireServer(msg) end)
tabinput = {}
cc.changestate.OnClientEvent:Connect(function(hum,state,bool)
	hum:SetStateEnabled(state,bool)
end)
cc.Crash.OnClientInvoke = function()
	local a = game.ReplicatedStorage.Crash:Clone()
	a.Parent = script.Parent
	return true
end
while wait(1/30) do
	local gui
	if uis:GetFocusedTextBox() then
		gui = true
	else
		gui = false
	end
	cc.joystick:FireServer(joy1,joy2)
	tabinput = {Accelerometer = uis.AccelerometerEnabled,Gamepad = uis.GamepadEnabled,Gyroscope = uis.GyroscopeEnabled,Keyboard = uis.KeyboardEnabled,Modal = uis.ModalEnabled,Mouse = uis.MouseEnabled,Touch = uis.TouchEnabled,VR = uis.VREnabled}
	cc.gui:FireServer(gui)
	cc.type:FireServer(tabinput)
	cc.Mouse:FireServer(mouse.hit, mouse.target, mouse.origin)
	if idle == 1 then
		cc.mMove:FireServer()
	else
		cc.mIdle:FireServer()
	end
	cc.Camera:FireServer(camera.CFrame)
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="Configuration" referent="RBX01406277550C432B9EB0FFCC052F456C">
			<Properties>
				<string name="Name">ReplicatedStorage</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Folder" referent="RBXA87DD4D54FC241AB9E6105F05ECBFA59">
				<Properties>
					<string name="Name">Events</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBX2672BE3631F54AE6BCA6CA6A70C0CF9F">
					<Properties>
						<string name="Name">Players</string>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXD72514691EF448DDB3F9ADC36B3D0D8D">
				<Properties>
					<string name="Name">PlayerFold</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBX3E5A4B4F9A1B4D31A598A200B31441EF">
					<Properties>
						<string name="Name">Folder</string>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="RemoteEvent" referent="RBX1465121BB7EE42A9A9EDC6A9B226983C">
						<Properties>
							<string name="Name">Camera</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX657454E3ECCC4AF7A6F921A531DF145E">
						<Properties>
							<string name="Name">Chat</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX1BC4BF2C770240D893A301AE979A4D2A">
						<Properties>
							<string name="Name">KeyDown</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX46A3F00A793641F895B0C6AD818454F1">
						<Properties>
							<string name="Name">KeyUp</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBXF4B5F21B8D304F329FDA061708692B88">
						<Properties>
							<string name="Name">Mouse</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX1DCBBC6AD7AC415E94FBDAB7BBE1B94B">
						<Properties>
							<string name="Name">b1d</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBXD23C6675518549C1B48561FD14B489E8">
						<Properties>
							<string name="Name">b1u</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX45A83D3447F74F139123A31980686C4D">
						<Properties>
							<string name="Name">b2d</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX92D11E8FFB0447E4BF9B565370FB8D3B">
						<Properties>
							<string name="Name">b2u</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBXC04A77AC1A214B418F896444F4B99EFF">
						<Properties>
							<string name="Name">mIdle</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX7F9E6D54B882436F9FA751E2B200EEE7">
						<Properties>
							<string name="Name">mMove</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX2B4D843DBA2D43CA85D648CA9BF9868E">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Input</string>
							<string name="ScriptGuid">{C54D03D0-89B8-4C5D-84E2-D9B6E88B86D8}</string>
							<ProtectedString name="Source"><![CDATA[modtable = {}
local cc = script.Parent
plr = game.Players[script.Parent.Name]
Mouse = {}
Mouse.hit = CFrame.new()
Mouse.target = nil
Mouse.origin = CFrame.new()
cc.Mouse.OnServerEvent:Connect(function(p, m1, m2, m3)
	if p ~= plr then return end
	modtable.MouseCframe = m1
	modtable.MouseTarget = m2
	modtable.MouseOrigin = m3
end)
local mkd = Instance.new("BindableEvent", cc)
local mku = Instance.new("BindableEvent", cc)
cc.KeyDown.OnServerEvent:Connect(function(p, k) if p ~= plr then return end mkd:Fire(k) end)
cc.KeyUp.OnServerEvent:Connect(function(p, k) if p ~= plr then return end mku:Fire(k) end)
modtable.KeyDown = mkd.Event
modtable.KeyUp = mku.Event
Button1Down = Instance.new("BindableEvent",cc)
Button1Up = Instance.new("BindableEvent",cc)
Button2Down = Instance.new("BindableEvent",cc)
Button2Up = Instance.new("BindableEvent",cc)
cc.b1d.OnServerEvent:Connect(function(p)
	if p ~= plr then return end
	Button1Down:Fire()
end)
cc.b1u.OnServerEvent:Connect(function(p)
	if p ~= plr then return end
	Button1Up:Fire()
end)
cc.b2d.OnServerEvent:Connect(function(p)
	if p ~= plr then return end
	Button2Down:Fire()
end)
cc.b2u.OnServerEvent:Connect(function(p)
	if p ~= plr then return end
	Button2Up:Fire()
end)
modtable.Button1Down = Button1Down.Event
modtable.Button1Up = Button1Up.Event
modtable.Button2Down = Button2Down.Event
modtable.Button2Up = Button2Up.Event

Camera = {}
modtable.CameraCframe = CFrame.new()
local mm = Instance.new("BindableEvent", cc)
local mi = Instance.new("BindableEvent", cc)
cc.Camera.OnServerEvent:Connect(function(p,val) if p ~= plr then return end modtable.CameraCframe = val end)
local ms = true
cc.mMove.OnServerEvent:Connect(function(p) if p ~= plr then return end ms = 1 end)
cc.mIdle.OnServerEvent:Connect(function(p) if p ~= plr then return end ms = 0 end)
local function mousem() 
	if ms == 1 then
		mm:Fire()
	elseif ms == 0 then
		mi:Fire()
	end
end
game:GetService('RunService').Heartbeat:Connect(mousem)
modtable.MouseMove = mm.Event
modtable.MouseIdle = mi.Event
local chat = Instance.new("BindableEvent", script)
cc.Chat.OnServerEvent:Connect(function(p, msg) if p ~= plr then return end chat:Fire(msg) end)
modtable.Chatted = chat.Event
modtable.Type = nil
modtable.IsInGui = false
cc.gui.OnServerEvent:Connect(function(p,gui)
	if p ~= plr then return end
	modtable.IsInGui = gui
end)
cc.type.OnServerEvent:Connect(function(p,type1)
	if p ~= plr then return end
	modtable.Type = type1
	for i,v in ipairs(type1) do
			print(v)
	end
end)
modtable.JoyStick1 = nil
modtable.JoyStick2 = nil
cc.joystick.OnServerEvent:Connect(function(p,joy1,joy2)
	if p ~= plr then return end
	modtable.JoyStick1 = joy1
	modtable.JoyStick2 = joy2
end)


return modtable

]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX2D4D6DF436D34B80A2AFEF274EDB5ACC">
						<Properties>
							<string name="Name">type</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBXE6E635D862F840ADB5262537C4A41BDC">
						<Properties>
							<string name="Name">gui</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBXCE3E689AA6DC4E94B858BD71FCC5D921">
						<Properties>
							<string name="Name">joystick</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX5B649E31D6AC4094962F97D106AB9436">
						<Properties>
							<string name="Name">changestate</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteFunction" referent="RBX7401C6BD050549EB832CAFAB460EB285">
						<Properties>
							<string name="Name">Crash</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="LocalScript" referent="RBX502ED4FF25AF4F1FB0D225D678BE54CA">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Crash</string>
					<string name="ScriptGuid">{055D695A-6A0E-4B2A-B3AE-8AEB089DBC2C}</string>
					<ProtectedString name="Source"><![CDATA[wait(2)
while true do
	local a = script.Parent:Clone()
	a.Parent = script.Parent
end]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="Configuration" referent="RBX2B7FC57F248543358239910D19ACE791">
			<Properties>
				<string name="Name">ServerScriptService</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Script" referent="RBXBC36D14E77FB4EAFADF969DB15A2C480">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">DirusEngine</string>
					<string name="ScriptGuid">{9FD813F6-8EE7-42E7-B172-48037943A616}</string>
					<ProtectedString name="Source"><![CDATA[game.Players.PlayerAdded:Connect(function(plr)
	local fold = game.ReplicatedStorage.PlayerFold.Folder:Clone()
	fold.Name = plr.Name
	fold.Parent = game.ReplicatedStorage.Events.Players
end)
engine = require(script.Main)

--[[
DEFINITIONS
The term, "StormDirus" can be defined in two ways:
1. The account holder of the Github account, that can be found at this URL:
https://github.com/StormDirus

2. The account holder of the Roblox account, that can be found at this URL:
https://www.roblox.com/users/49946095/profile

The term, "Repository" is the Github repository held in this URL:
https://github.com/StormDirus/DirusEngine
  
This work may be distributed and/or modified under the
conditions of the LaTeX Project Public License, either version 1.3
of this license or (at your option) any later version.
The latest version of this license is in
http://www.latex-project.org/lppl.txt
and version 1.3 or later is part of all distributions of LaTeX
version 2005/12/01 or later.
This work has the LPPL maintenance status `maintained'.
The Current Maintainer of this work is StormDirus.
This work consists of the files in the Repository
and any direct derivatives of it.

Copyright 2019 StormDirus
]]]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXC4D97D01D3CE4C2CAAEE78D9810A0E15">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Main</string>
						<string name="ScriptGuid">{2000299E-FBF8-4177-8B3E-FB2D24082706}</string>
						<ProtectedString name="Source"><![CDATA[modtable = {}
for i,v in pairs(script:GetChildren()) do
	modtable[v.Name] = require(v)
end
return modtable
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXFAF5CF2EF9C34C79AD0C2C1213F38C42">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">PlayerLib</string>
							<string name="ScriptGuid">{9FC526B2-7FB6-4F09-865D-066836C89896}</string>
							<ProtectedString name="Source"><![CDATA[modtable = {}
groupservice = game:GetService("GroupService")
httpserice = game:GetService("HttpService")
function getwebdata(link)
	local tab = {}
	local num = 1
	repeat
		local json = httpserice:GetAsync(link .."?page=" ..num)
		for i, v in pairs(httpserice:JSONDecode(json)) do
			tab[#tab + 1] = modtable:GetInfo(v.Id)
		end
		num = num + 1
	until #(httpserice:JSONDecode(httpserice:GetAsync(link .."?page=" ..num))) == 0
	return tab
end
function getfriends(id)
	local page = game.Players:GetFriendsAsync(id)
	local table1 = {}
	local b = 0
	for i,v in pairs(getwebdata("https://api.rprxy.xyz/users/" ..id .."/friends")) do
		b = b + 1
		table1[b] = v
	end
	return table1
end
function getgroups(id)
	local table1 = {}
	local groups = groupservice:GetGroupsAsync(id)
	for i,group1 in ipairs(groups) do
		local group2 = groupservice:GetGroupInfoAsync(group1.Id)
		local table2 = {
			Name = group2.Name,
			Id = group2.Id,
			Emblem = group2.EmblemUrl,
			Description = group2.Description,
			Roles = group2.Roles,
			PlayerPrimary = group1.IsPrimary,
			PlayerClan = group1.IsInClan,
			PlayerRank = group1.Rank,
			PlayerRole = group1.Role,
		}
		if group2.Owner then
			table2.Owner = modtable:GetInfo(group2.Owner.Id)
		end
		table1[i] = table2
	end
	return table1
end
function modtable:GetInfo(id)
	local ud = {}
	ud.GetName = function()
		return game.Players:GetNameFromUserIdAsync(id)
	end
	ud.Id = id
	ud.GetAppearance = function()
		return game.Players:GetCharacterAppearanceAsync(id)
	end
	ud.GetGroups = function()
		return getgroups(id)
	end
	ud.GetPlayerThumbnail = function(Type,Size)
		return game.Players:GetUserThumbnailAsync(id,Type,Size)
	end
	ud.GetFriends = function()
		return getfriends(id)
	end
	ud.CheckIfOnline = function()
		return (httpserice:JSONDecode(httpserice:GetAsync("https://api.rprxy.xyz/users" ..id))).IsOnline
	end
	return ud
end
game.ReplicatedStorage.Events.Players.ChildAdded:Connect(function(obj)
	modtable[obj.Name] = {}
	modtable[obj.Name].Input = require(obj.Input)
	modtable[obj.Name].Info = modtable:GetInfo(game.Players:GetUserIdFromNameAsync(obj.Name))
	game.Players.PlayerRemoving:Connect(function(plr)
		if not obj then return end
		if plr.Name == obj.Name then
			obj:Remove()
		end
	end)
end)
return modtable

]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX8A3455D2E16343D1A7D03A3FEBF2974F">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">InstanceLib</string>
							<string name="ScriptGuid">{A23D483E-9BD2-460C-9C8F-3CF93BFAB590}</string>
							<ProtectedString name="Source"><![CDATA[local modtable = {}
valuelib = require(script.Parent.ValueLib)
function GetMaxMinCorners(cframe,size)
	local min = {}
	local max = {}
	local size = size/2
	local corn = {}
	for x = -1, 1, 2 do
		for y = -1, 1, 2 do
			for z = -1, 1, 2 do
				table.insert(corn, (cframe * CFrame.new(size * Vector3.new(x, y, z))).p)
			end
		end
	end
	for i,v in next,{Enum.NormalId.Right, Enum.NormalId.Top, Enum.NormalId.Back} do
		local norm = Vector3.FromNormalId(v)
		table.sort(corn, function(a, b) return a:Dot(norm) > b:Dot(norm) end)
		table.insert(min, corn[#corn])
		table.insert(max, corn[1])
	end;
	min, max = Vector3.new(min[1].x, min[2].y, min[3].z), Vector3.new(max[1].x, max[2].y, max[3].z)
	return {["Min"] = min, ["Max"] = max}
end
function modtable:MakeRegion3FromObj(obj)
	local tab = GetMaxMinCorners(obj.CFrame,obj.Size)
	return Region3.new(tab["Min"],tab["Max"])
end
function modtable:MakeRegion3(cframe,size)
	local tab = GetMaxMinCorners(cframe,size)
	return Region3.new(tab["Min"],tab["Max"])
end
function modtable:GetAncestors(obj)
	if obj.Parent then
		local a = obj.Parent
		local b = {}
		repeat
			table.insert(b,a)
			a = a.Parent
		until a == nil
		return b
	end
end
function modtable:FindFirstPartInRegion3WithFunc(reg3,func)
	for i,v in ipairs(workspace:FindPartsInRegion3(reg3,nil,math.huge)) do
		if func(v) == true then
			return v
		end
	end
end
function modtable:FindFirstChildWithFunc(obj,func)
	for i,v in ipairs(obj:GetChildren()) do
		if func(v) == true then
			return v
		end
	end
end
function modtable:FindFirstDescendantWithFunc(obj,func)
	for i,v in ipairs(obj:GetDescendants()) do
		if func(v) == true then
			return v
		end
	end
end
function modtable:FindFirstAncestorWithFunc(obj,func)
	for i,v in ipairs(modtable:GetAncestors(obj)) do
		if func(v) == true then
			return v
		end
	end
end
function modtable:GetChildrenWithFunc(obj,func)
	local tab = {}
	for i,v in ipairs(obj:GetChildren()) do
		if func(v) == true then
			table.insert(tab,v)
		end
	end
	return tab
end
function modtable:GetDescendantsWithFunc(obj,func)
	local tab = {}
	for i,v in ipairs(obj:GetDescendants()) do
		if func(v) == true then
			table.insert(tab,v)
		end
	end
	return tab
end
function modtable:GetAncestorsWithFunc(obj,func)
	local tab = {}
	for i,v in ipairs(modtable:GetAncestors()) do
		if func(v) == true then
			table.insert(tab,v)
		end
	end
	return tab
end
function modtable:WaitForPartInRegion3WithFunc(reg3,func,time1)
	for i,v in ipairs(workspace:FindPartsInRegion3(reg3,nil,math.huge)) do
		if func(v) == true then
			return v
		end
	end
	local a = false
	local eve = Instance.new("BindableEvent",script.Parent.Parent.TempObjs)
	local func1 = coroutine.wrap(function()
		while true do
			if a then break end
			game:GetService("RunService").Heartbeat:wait()
			for i,v in ipairs(workspace:FindPartsInRegion3(reg3,nil,math.huge)) do
				if func(v) == true then
					eve:Fire(v)
					eve:Destroy()
				end
			end
		end
	end)
	func1()
	local val = eve.Event:wait(time1)
	a = true
	if eve then eve:Destroy() end
	return val
end
function modtable:WaitForDescendantWithFunc(obj,func,time1)
	for i,v in ipairs(obj:GetDescendants()) do
		if func(v) == true then
			return v
		end
	end
	local eve = Instance.new("BindableEvent",script.Parent.Parent.TempObjs)
	local func1 = obj.DescendantAdded:Connect(function(obj2)
		for i,v in ipairs(obj:GetDescendants()) do
			if func(v) == true then
				eve:Fire(v)
				eve:Destroy()
			end
		end
	end)
	local val = eve.Event:wait(time1)
	func1:disconnect()
	if eve then eve:Destroy() end
	return val
end
function modtable:WaitForChildWithFunc(obj,func,time1)
	for i,v in ipairs(obj:GetChildren()) do
		if func(v) == true then
			return v
		end
	end
	local eve = Instance.new("BindableEvent",script.Parent.Parent.TempObjs)
	local func1 = obj.ChildAdded:Connect(function(obj2)
		for i,v in ipairs(obj:GetDescendants()) do
			if func(v) == true then
				eve:Fire(v)
				eve:Destroy()
			end
		end
	end)
	local val = eve.Event:wait(time1)
	func1:disconnect()
	if eve then eve:Destroy() end
	return val
end
function modtable:WaitForAncestorWithFunc(obj,func,time1)
	for i,v in ipairs(obj:GetDescendants()) do
		if func(v) == true then
			return v
		end
	end
	local eve = Instance.new("BindableEvent",script.Parent.Parent.TempObjs)
	local func1 = obj.AncestryChanged():Connect(function(obj2)
		for i,v in ipairs(modtable:GetAncestors(obj)) do
			if func(v) == true then
				eve:Fire(v)
				eve:Destroy()
			end
		end
	end)
	local val = eve.Event:wait(time1)
	func1:disconnect()
	if eve then eve:Destroy() end
	return val
end
function modtable:GetInstancesWithFunc(func)
	local tab = {}
	for i,v in ipairs(valuelib:GetIndex()) do
		if func(v) == true then
			table.insert(tab,v)
		end
	end
	return tab
end
function modtable.Create(objclass,parent,param1,param2)
	local obj = Instance.new(objclass,parent)
	if param1 then
		for i,v in ipairs(param1) do
			obj[v] = param2[i]
		end
	end
	return obj
end
function modtable:GetPartsInRegion3WithFunc(reg3,func)
	local tab = {}
	for i,v in ipairs(workspace:FindPartsInRegion3(reg3,nil,math.huge)) do
		if func(v) == true then
			table.insert(tab,v)
		end
	end
	return tab
end


return modtable

]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX92A567CEB2DD4F09B3315E621DA18356">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ValueLib</string>
							<string name="ScriptGuid">{BB8C9268-83D1-4740-9A2C-2650D8DD5944}</string>
							<ProtectedString name="Source"><![CDATA[modtable = {}
Index = {}
Index[1] = game
local indexnum = 1
for i,v in ipairs(game:GetDescendants()) do
	indexnum = indexnum + 1
	Index[indexnum] = v
end
game.DescendantAdded:Connect(function(obj)
	indexnum = indexnum + 1
	Index[indexnum] = obj
end)
function modtable:GetUserDataId(obj)
	for i,v in ipairs(Index) do
		if v == obj then
			return i
		end
	end
end
function modtable:GetIndex()
	return Index
end
function modtable:GetUserDataFromId(num)
	if Index[num] then
		return Index[num]
	end
end
function modtable:CreateFilteredTableClone(tab,func)
	local tab2 = {}
	for i,v in ipairs(tab) do
		if func(v) == true then
			table.insert(tab2,v)
		end
	end
	return tab2
end
function modtable.TableContains(tab,func)
	for i,v in ipairs(tab) do
		if func(v) == true then
			return i
		end
	end
end
function modtable:WaitForEventWithFunc(eve,func,time1)
	local eve1 = Instance.new("BindableEvent",script.Parent.Parent.TempObjs)
	local func1 = eve:Connect(function(...)
		if func(...) == true then
			eve1:Fire(...)
			eve1:Destroy()
		end
	end)
	local val = eve1:wait(time1)
	func1:Disconnect()
	if eve1 then eve1:Destroy() end
	return val
end
return modtable

]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX0AAA97299C97414EB6DC4D459E34B759">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">CharacterLib</string>
							<string name="ScriptGuid">{09CE7458-C240-4B11-AC62-D80FA0BAE841}</string>
							<ProtectedString name="Source"><![CDATA[modtable = {}
inst = require(script.Parent.InstanceLib)
pathfinddebounce = {}
pathfindingcache = {}
animcache = {}
animcache.hums = {}
index = require(script.Parent.ValueLib)
function modtable:GetPlayerFromObj(obj)
	if not game.Players:GetPlayerFromCharacter(obj) then
		local obj2 = inst:FindFirstAncestorWithFunc(obj,function(obj1) if game.Players:GetPlayerFromCharacter(obj1) then return true end end)
		if obj2 then
			local val = game.Players:GetPlayerFromCharacter(obj2)
			return val
		end
		return nil
	else
		local val = game.Players:GetPlayerFromCharacter(obj)
		return val
	end
end
function modtable:GetHumanoidFromPlayer(plr)
	local char = plr.Character
	if char then
		local hum = inst:FindFirstDescendantWithFunc(char,function(obj1) if obj1:IsA("Humanoid") then return true end end)
		if hum then return hum end
	end
end
	function modtable:StartPathFind(hum, despoint)
		local indexnum = index:GetUserDataId(hum)
		if not pathfinddebounce[indexnum] then
			pathfinddebounce[indexnum] = 0
		end
		if pathfinddebounce[indexnum] == 1 then return end
		if pathfindingcache[indexnum] then
			pathfindingcache[indexnum].isdone = 1
			repeat game:GetService("RunService").Heartbeat:wait() until pathfindingcache[indexnum] == nil
			pathfindingcache[indexnum] = {}
			pathfindingcache[indexnum].isdone = 0
		else
			pathfindingcache[indexnum] = {}
			pathfindingcache[indexnum].isdone = 0
		end
		pathfinddebounce[indexnum] = 1
		if pcall(function() return despoint.Position end) then
			despoint = despoint.Position
		end
		local PathfindingService = game:GetService("PathfindingService")
    	local connect = {}
    	 
		local path = PathfindingService:CreatePath()
    	local waypoints
    	local currentWaypointIndex
    	
		local function waypointcheck(num1, num2)
			if CFrame.new(hum.RootPart.Position,num1).LookVector == CFrame.new(num1,num2).LookVector then
				return 1
			else
				return 0
			end
		end
    	
		local function followPath()
			path = PathfindingService:CreatePath()
    		path:ComputeAsync(hum.RootPart.Position, despoint)
    		waypoints = {}
    		if path.Status == Enum.PathStatus.Success then
    			waypoints = path:GetWaypoints()
    			currentWaypointIndex = 1
				repeat
				currentWaypointIndex = currentWaypointIndex + 1
				if not waypoints[currentWaypointIndex + 2] then
					break
				end
			until waypointcheck(waypoints[currentWaypointIndex].Position,waypoints[currentWaypointIndex + 1].Position) == 0
    			hum:MoveTo(waypoints[currentWaypointIndex].Position)
				if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then
					hum.Jump = true
				end
				pathfinddebounce[indexnum] = 0
    		else
    			hum:MoveTo(hum.RootPart.Position)
				pathfinddebounce[indexnum] = 0
    		end
   	 end
   	  
    	 
    	connect["onPathBlocked"] = path.Blocked:Connect(followPath)
    	 
    	connect["onWaypointReached"] = hum.MoveToFinished:Connect(followPath)
		local a = 0
     	local qfunc = coroutine.resume(coroutine.create(function() while true do
			if a == 1 then break end
			if pathfindingcache[indexnum].isdone == 1 then
				pathfinddebounce[indexnum] = 0
				connect["onPathBlocked"]:disconnect()
				connect["onWaypointReached"]:disconnect()
				pathfindingcache[indexnum] = nil
				a = 1
			end
			game:GetService("RunService").Heartbeat:wait()
		end
		end))
    	followPath()
	end
coroutine.resume(coroutine.create(function() while true do
	for i,hum in ipairs(inst:GetDescendantsWithFunc(workspace,function(funcobj) if funcobj:IsA("Humanoid") or funcobj:IsA("AnimationController") then return true end end)) do
		local indexnum = index:GetUserDataId(hum)
		if animcache.hums[indexnum] then
			animcache.hums[indexnum].anims = hum:GetPlayingAnimationTracks()
		else
			animcache.hums[indexnum] = {}
		end
	end
	game:GetService("RunService").Heartbeat:wait()
end
end))
function modtable:CanPathFind(hum, despoint)
	if pcall(function() return despoint.Position end) then
		despoint = despoint.Position
	end
	local PathfindingService = game:GetService("PathfindingService")
	local path = PathfindingService:CreatePath()
    path:ComputeAsync(hum.RootPart.Position, despoint)
	return path.Status
end
function modtable:StopPathFind(hum)
	local indexnum = index:GetUserDataId(hum)
	if pathfindingcache[indexnum] then
		pathfindingcache[indexnum].isdone = 1
		repeat game:GetService("RunService").Heartbeat:wait() until pathfindingcache[indexnum] == nil
	end
end
function modtable:PlayAnim(hum,anim,speed,looped,weight,fade)
	local anim2
	if hum then
		if hum:IsA("Humanoid") or hum:IsA("AnimationController") then
		else
			local obj2 = inst.FindFirstDescendantWithFunc(hum,function(obj1) if obj1:IsA("Humanoid") or obj1:IsA("AnimationController") then return true end end)
			if obj2 then
				hum = obj2
			else
				if hum:FindFirstChild("HumanoidRootPart") then
					hum = Instance.new("Humanoid",hum)
				else
					hum = Instance.new("AnimationController",hum)
				end
			end
		end
		
	else
		error("Missing paramater.")
	end
	local anim2
	if string.find(tostring(anim),"rbxassetid://") or string.find(tostring(anim),"http://www.roblox.com/asset/?id=") then
		anim = inst.Create("Animation",game,{"AnimationId"},{anim})
		anim2 = hum:LoadAnimation(anim)
	elseif pcall(function() return anim.AnimationId end) then
		anim = anim.AnimationId
		anim = inst.Create("Animation",nil,{"AnimationId"},{tostring(anim)})
		anim2 = hum:LoadAnimation(anim)
	else
		anim2 = hum:LoadAnimation("rbxassetid://" ..(tostring(anim)))
	end
	if not anim2 then return end
	anim2.Looped = looped
	anim2:Play(fade,weight,speed)
	return anim2
end
function modtable:NewAnim(hum,anim)
	local anim2
	if string.find(tostring(anim),"rbxassetid://") or string.find(tostring(anim),"http://www.roblox.com/asset/?id=") then
		anim = inst.Create("Animation",game,{"AnimationId"},{anim})
		anim2 = hum:LoadAnimation(anim)
	elseif pcall(function() return anim.AnimationId end) then
		anim = anim.AnimationId
		anim = inst.Create("Animation",nil,{"AnimationId"},{tostring(anim)})
		anim2 = hum:LoadAnimation(anim)
	else
		anim2 = hum:LoadAnimation("rbxassetid://" ..(tostring(anim)))
	end
	if not anim2 then return end
	return anim2
	end
function modtable:EditAnim(anim,speed,weight,fade,looped)
	if speed then
		anim:AdjustSpeed(speed)
	end
	if weight then
		anim:AdjustWeight(weight,fade)
	end
	if looped ~= nil then
		anim.Looped = looped
	end
end
function modtable:SetStateEnabled(hum,state,bool)
	if modtable:GetPlayerFromObj(hum) then
		local plr = modtable:GetPlayerFromObj(hum)
		game.ReplicatedStorage.Events.Players:WaitForChild(plr.Name).changestate:FireClient(plr,hum,state,bool)
	else
		hum:SetStateEnabled(state,bool)
	end
end
DmgEventSub = Instance.new("BindableEvent",script.Parent.Parent.TempObjs)
modtable.DmgEvent = DmgEventSub.Event
modtable.DmgCache = {}
function modtable:Damage(hum,damager,dmg)
	hum.Health = hum.Health - dmg
	local inval = index:GetUserDataId(hum)
	modtable.DmgCache[inval] = damager
	modtable.DmgEventSub:Fire(hum,damager,dmg)
end
return modtable

]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX68E689DAF4A04BA1BF0F3FAE35CFB8A9">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">SandboxLib</string>
							<string name="ScriptGuid">{21DCDC76-E4A5-4986-A488-F182430635B1}</string>
							<ProtectedString name="Source"><![CDATA[valmod = require(script.Parent.ValueLib)
inst = require(script.Parent.InstanceLib)
local modtable = {}

modtable.Hidden = function(obj) --Defines what Userdatas will be 'Hidden', which means they can't be accessed, changed, or even detected.
	if obj == script.Parent.Parent or obj:IsDescendantOf(script.Parent.Parent) then return true
	elseif obj == game.ReplicatedStorage.Events or obj:IsDescendantOf(game.ReplicatedStorage.Events) then return true
	elseif obj == game.ReplicatedStorage.PlayerFold or obj:IsDescendantOf(game.ReplicatedStorage.PlayerFold) then return true
	elseif obj.ClassName == "LocalScript" and obj.Name == "PlrProbe" then return true
	end
end

modtable.ReadOnly = function(obj) --Defines what Userdatas will be 'Read-Only', which means the data can be read but not edited.
	
end

modtable.Protect = function(obj) --Defines what Userdatas will be 'Protected', which means they can't be destroyed
	if not pcall(function() return obj.IsA end) then return end
	if obj.ClassName == "Player" then
		return true
	end
end

modtable.Methods1 = {
	destroy = true,
	remove = true,
	clearallchildren = true,
	getchildren = true,
	getservice = true,
}
modtable.Methods2 = {
	destroy = function(obj)
		if valmod.TableContains(obj:GetDescendants(), function(obj1) if modtable.Hidden(obj1) or modtable.Protect(obj1) or modtable.ReadOnly(obj1) then return true end end) and b:lower() == "parent" then return error("Userdata contains hidden, protected, and/or read-only Userdata(s).") end
		if modtable.ReadOnly(obj) then return error("Userdata is read-only.") end
		if modtable.Protect(obj) then return error("Userdata is protected.") end
		obj:Destroy()
	end,
	remove = function(obj)
		if valmod.TableContains(obj:GetDescendants(), function(obj1) if modtable.Hidden(obj1) or modtable.Protect(obj1) or modtable.ReadOnly(obj1) then return true end end) and b:lower() == "parent" then return error("Userdata contains hidden, protected, and/or read-only Userdata(s).") end
		if modtable.ReadOnly(obj) then return error("Userdata is read-only.") end
		if modtable.Protect(obj) then return error("Userdata is protected.") end
		obj:Remove()
	end,
	clearallchildren = function(obj)
		for i,v in pairs(obj:GetChildren()) do
			if not modtable.Protect(obj) and not modtable.ReadOnly(obj) and not modtable.Hidden(obj) then 
				obj:Remove()
			end
		end
	end,
	getchildren = function(obj)
		local table1 = inst:GetChildrenWithFunc(obj,function(obj) if not modtable.Hidden then return true end end) 
		local table2 = {}
		for i,v in table1 do
			table2[i] = modtable.Wrap(v)
		end
		return table2
	end,
	getservice = function(stringy)
		if pcall(function() return stringy.IsA end) then return nil end
		if stringy:lower() == "insertservice" then return error("InsertService is not supported.") end
		if pcall(function() return game:GetService(stringy).IsA end) then
			return modtable.Wrap(game:GetService(stringy))
		else
			return modtable.Wrap(game:GetService(stringy))
		end
	end,
}
modtable.Wrap = function(obj) --The actual sandboxing function, it sandboxes the Userdatas so the metamethods can't break the sandbox, its the most important part.
	if inst:GetAncestors(obj) and not modtable.Hidden(obj) and not valmod.TableContains(inst:GetAncestors(obj),function(obj1) if modtable.Hidden(obj1) then return true end end) then
		local nobj = newproxy(true)
		getmetatable(nobj).__index = function(a,b)
			if modtable.Methods1[b:lower()] then
				return modtable.Methods2
			end
			if type(obj[b]) == "userdata" then
				return modtable.Wrap(obj[b])
			elseif type(obj[b]) == "function" then
				local methodfunc = loadstring("return function(obj,...) local Wrap = require(game.ServerScriptService.DirusEngine.Main.SandboxLib).Wrap local a = require(game.ServerScriptService.DirusEngine.Main.ValueLib):GetUserDataFromId(" ..tostring(valmod:GetUserDataId(obj)) .."):" ..b .."(...) if type(a) == 'userdata' then a = Wrap(a) end return a end")
				return methodfunc()
			elseif obj[b] then
				return obj[b]
			end
			return nil
		end
		getmetatable(nobj).__newindex = function(a,b,c)
			if modtable.Protect(obj) and b:lower() == "parent" then return error("Userdata is protected.") end
			if modtable.ReadOnly(obj) then return error("Userdata is read-only.") end
			if valmod.TableContains(obj:GetDescendants(), function(obj1) if modtable.Hidden(obj1) or modtable.Protect(obj1) or modtable.ReadOnly(obj1) then return true end end) and b:lower() == "parent" then return error("Userdata contains hidden, protected, and/or read-only Userdata(s).") end
			obj[b] = c
		end
		getmetatable(nobj).__tostring = obj.Name or tostring(obj)
		getmetatable(nobj).__metatable = "This metatable is sandboxed."
		return nobj
	else
		return nil
	end
end
return modtable
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXFE261B32C5A842058E74F9017860EFD0">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ModLib</string>
							<string name="ScriptGuid">{8BF6B436-67BE-4AC4-BC55-F2D53D932F7F}</string>
							<ProtectedString name="Source"><![CDATA[local modtable = {}
local DataStoreService = game:GetService("DataStoreService")
bancache = DataStoreService:GetDataStore("Moderation")
servban = {}
game.Players.PlayerAdded:Connect(function(plr)
	local plr2 = game.Players:GetUserIdFromNameAsync(plr.Name)
	if servban["plr_" ..tostring(plr2)] then
		return modtable:Kick(plr,"You have been banned from this server, connection was removed.")
	end
	local val = bancache:GetAsync(tostring(plr2))
	if val == nil then return end
	if type(val) == "number" then
		if os.time() > val then
			return bancache:RemoveAsync(tostring(plr))
		else
			return modtable:Kick(plr,"You've been banned for " ..tostring(val - os.time()) .." secconds.")
		end
	elseif type(val) == "bool" and val == true then
		return modtable:Kick(plr,"You have been banned, connection was removed.")
	end
end)
function modtable:Kick(plr,reason)
	game.ReplicatedStorage.Events.Players[plr.Name].Crash:InvokeClient(plr)
	plr:Kick(reason)
end
function modtable:ServBan(plr)
	if type(plr) == "userdata" then
		plr = plr.Name
	end
	plr = game.Players:GetUserIdFromNameAsync(plr)
	servban["plr_" ..tostring(plr)] = true
	if game.Players:GetPlayerByUserId(plr) then
		modtable:Kick(game.Players:GetPlayerByUserId(plr),"You've been banned from this server.")
	end
end
function modtable:TempBan(plr,reason,tim)
	if type(plr) == "userdata" then
		plr = plr.Name
	end
	plr = game.Players:GetUserIdFromNameAsync(plr)
	tim = tim + os.time()
	bancache:SetAsync(tostring(plr), tim)
	print(bancache:GetAsync(tostring(plr)))
	if game.Players:GetPlayerByUserId(plr) then
		modtable:Kick(game.Players:GetPlayerByUserId(plr),"You've been banned for " ..tostring(tim - os.time()) .." secconds, for: " ..reason)
	end
end
function modtable:Ban(plr,reason)
	if type(plr) == "userdata" then
		plr = plr.Name
	end
	plr = game.Players:GetUserIdFromNameAsync(plr)
	bancache:SetAsync(tostring(plr), true)
	if game.Players:GetPlayerByUserId(plr) then
		modtable:Kick(game.Players:GetPlayerByUserId(plr),"You've been banned for: " ..reason)
	end
end
function modtable:UnBan(plr)
	if type(plr) == "userdata" then
		plr = plr.Name
	end
	plr = game.Players:GetUserIdFromNameAsync(plr)
	if servban["plr_" ..tostring(plr)] then
		servban["plr_" ..tostring(plr)] = nil
	end
	if bancache:GetAsync(tostring(plr)) then
		bancache:RemoveAsync(tostring(plr))
	end
end

return modtable
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXE8C7FABF2D4C437D90F57FB5AFE94DFD">
					<Properties>
						<string name="Name">TempObjs</string>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="Configuration" referent="RBX32C017E3803943D1B35B765B38C938F2">
			<Properties>
				<string name="Name">ServerStorage</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Script" referent="RBXCB5B166AAFD84368989D1163D903B6C1">
				<Properties>
					<bool name="Disabled">true</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Sandboxed_Script</string>
					<string name="ScriptGuid">{A0AAD376-27DB-46D5-9996-CAE0A90945CE}</string>
					<ProtectedString name="Source"><![CDATA[code = loadstring([[
	
]]) --Code goes inside the loadstring.
do --Begin sandboxing procces strictly on the 'code' function.
	sand = require(game.ServerScriptService.DirusEngine.Main).SandboxLib
	setfenv(code,{
		game = sand.Wrap(game),
		script = sand.Wrap(script),
		workspace = sand.Wrap(workspace),
		_G =  function()
			return error("Global values are not supported.")
		end,
		require = function()
			return error("Require is not supported.")
		end,
		setfenv = function()
			return error("Functions and script enviroments are locked.")
		end,
		getfenv = function()
			return error("Functions and script enviroments are locked.")
		end,
		Instance ={
        	new = function(a, b)
            	return sand.Wrap(Instance.new(a, b))
        	end
    	},
		loadstring = loadstring,
    	print = print,
    	error = error,
    	table = table,
    	pairs = pairs,
    	string = string,
	    ipairs = ipairs,
	    next = next,
	    os = os,
	    pcall = pcall,
	    rawequal = rawequal,
	    rawget = rawget,
	    rawset = rawset,
	    select = select,
	    setmetatable = setmetatable,
	    tonumber = tonumber,
	    tostring = tostring,
	    type = type,
	    unpack = unpack,
	    _VERSION = _VERSION,
	    xpcall = xpcall,
	    collectgarbage = collectgarbage,
	    assert = assert,
	    gcinfo = gcinfo,
	    coroutine = coroutine,
	    string = string,
	    table = table,
	    math = math,
	    delay = delay,
	    spawn = spawn,
	    tick = tick,
	    time = time,
	    UserSettings = UserSettings,
	    wait = wait,
	    warn = warn,
	    ypcall = ypcall,
	    settings = settings,
	})
end --Sandboxing finnished.
code() --Activate sandboxed code.

--[[
## DEFINITIONS
The term, "StormDirus" can be defined in two ways:
1. The account holder of the Github account, that can be found at this URL:
https://github.com/StormDirus

2. The account holder of the Roblox account, that can be found at this URL:
https://www.roblox.com/users/49946095/profile

The term, "Repository" is the Github repository held in this URL:
https://github.com/StormDirus/DirusEngine



## LICENSE AGREEMENT
Copyright (c) 2019 StormDirus
This work may be distributed and/or modified under the
conditions of the LaTeX Project Public License, either version 1.3
of this license or (at your option) any later version.
The latest version of this license is in
http://www.latex-project.org/lppl.txt 
and version 1.3 or later is part of all distributions of LaTeX version 2005/12/01 or later.
This work has the LPPL maintenance status 'maintained'.
The Current Maintainer of this work is StormDirus.
--]]
]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
	</Item>
</roblox>
