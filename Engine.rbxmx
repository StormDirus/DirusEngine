<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<Meta name="ExplicitAutoJoints">true</Meta>
	<External>null</External>
	<External>nil</External>
	<Item class="Folder" referent="RBX233C0DEBD7724956B4E8B3CF7CC4ED1A">
		<Properties>
			<string name="Name">Files</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Configuration" referent="RBXCDB244DA627F4F84AEAFC4BB9CC448D6">
			<Properties>
				<string name="Name">StarterPlayer</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Configuration" referent="RBXEDBDED86AA434CE58C70BA476629CA1B">
				<Properties>
					<string name="Name">StarterPlayerScripts</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="LocalScript" referent="RBX9A398DEE61DE415B9EBEC4A6CA502736">
					<Properties>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">PlrProbe</string>
						<string name="ScriptGuid">{AA912D97-E588-4E52-B452-65E563865237}</string>
						<ProtectedString name="Source"><![CDATA[joy1 = {}
joy1.Delta = Vector3.new(0,0,0)
joy1.Position = Vector3.new(0,0,0)
joy2 = {}
joy2.Delta = Vector3.new(0,0,0)
joy2.Position = Vector3.new(0,0,0)
plr = game.Players.LocalPlayer
mouse = plr:GetMouse()
camera = workspace.CurrentCamera
idle = 0
uis = game:GetService("UserInputService")
uis.InputChanged:Connect(function(input,gp)
	if input.KeyCode == Enum.KeyCode.Thumbstick1 then
		joy1.Delta = input.Delta
		joy1.Position = input.Position
	elseif input.KeyCode == Enum.KeyCode.Thumbstick2 then
		joy2.Delta = input.Delta
		joy2.Position = input.Position
	end
end)
uis.InputBegan:Connect(function(input, gpe)
	game.ReplicatedStorage.Events.Players:WaitForChild(plr.Name).KeyDown:FireServer(input.KeyCode)
end)
uis.InputEnded:Connect(function(input, gpe)
	game.ReplicatedStorage.Events.Players:WaitForChild(plr.Name).KeyUp:FireServer(input.KeyCode)
end)
mouse.Button1Down:Connect(function() game.ReplicatedStorage.Events.Players:WaitForChild(plr.Name).b1d:FireServer() end)
mouse.Button1Up:Connect(function() game.ReplicatedStorage.Events.Players:WaitForChild(plr.Name).b1u:FireServer() end)
mouse.Button2Down:Connect(function() game.ReplicatedStorage.Events.Players:WaitForChild(plr.Name).b2d:FireServer() end)
mouse.Button2Up:Connect(function() game.ReplicatedStorage.Events.Players:WaitForChild(plr.Name).b2d:FireServer() end)
mouse.Move:Connect(function() idle = 1 end)
mouse.Idle:Connect(function() idle = 0 end)
plr.Chatted:Connect(function(msg) game.ReplicatedStorage.Events.Players:WaitForChild(plr.Name).Chat:FireServer(msg) end)
tabinput = {}
while wait(1/30) do
	local gui
	if uis:GetFocusedTextBox() then
		gui = true
	else
		gui = false
	end
	game.ReplicatedStorage.Events.Players:WaitForChild(plr.Name).joystick:FireServer(joy1,joy2)
	tabinput = {Accelerometer = uis.AccelerometerEnabled,Gamepad = uis.GamepadEnabled,Gyroscope = uis.GyroscopeEnabled,Keyboard = uis.KeyboardEnabled,Modal = uis.ModalEnabled,Mouse = uis.MouseEnabled,Touch = uis.TouchEnabled,VR = uis.VREnabled}
	game.ReplicatedStorage.Events.Players:WaitForChild(plr.Name).gui:FireServer(gui)
	game.ReplicatedStorage.Events.Players:WaitForChild(plr.Name).type:FireServer(tabinput)
	game.ReplicatedStorage.Events.Players:WaitForChild(plr.Name).Mouse:FireServer(mouse.hit, mouse.target, mouse.origin)
	if idle == 1 then
		game.ReplicatedStorage.Events.Players:WaitForChild(plr.Name).mMove:FireServer()
	else
		game.ReplicatedStorage.Events.Players:WaitForChild(plr.Name).mIdle:FireServer()
	end
	game.ReplicatedStorage.Events.Players:WaitForChild(plr.Name).Camera:FireServer(camera.CFrame)
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="Configuration" referent="RBXF72EFBA85AA54E429F8EB2382CAC4E72">
			<Properties>
				<string name="Name">ReplicatedStorage</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Folder" referent="RBXCF16A179F9F142DAB8C5EAEC7A474388">
				<Properties>
					<string name="Name">Events</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBX3A96027A4BE24EC4B6A91A14A8DE8E41">
					<Properties>
						<string name="Name">Players</string>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX7BF0AA8123AC4EFDB6EE6DF24F39B13B">
				<Properties>
					<string name="Name">PlayerFold</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBX4AE84C6DAF434D418DDF792837CCE49F">
					<Properties>
						<string name="Name">Folder</string>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="RemoteEvent" referent="RBXB1BCE5D481914DD6843DB94E20ADFFC5">
						<Properties>
							<string name="Name">Camera</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX0CEF054EDA9E41849577E44519B47515">
						<Properties>
							<string name="Name">Chat</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX27F2C9BB98F042DCBE02AF63B850DBB3">
						<Properties>
							<string name="Name">KeyDown</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX5F56837AB54647CC8143274CB41D7DF6">
						<Properties>
							<string name="Name">KeyUp</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX8D3D85A303584D5AA7460F3D273ACF05">
						<Properties>
							<string name="Name">Mouse</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX3DD7A8DD26104D2B8252E2F797057FC1">
						<Properties>
							<string name="Name">b1d</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX75A234F7863D409194222C78FF28615A">
						<Properties>
							<string name="Name">b1u</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX9488A6404FC84EBAB9CAFF5728A2B0EB">
						<Properties>
							<string name="Name">b2d</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX99826E04465E491EB35995924D12FB80">
						<Properties>
							<string name="Name">b2u</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX218575E893F44DAF8D54B03C3FBD2BBC">
						<Properties>
							<string name="Name">mIdle</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX0F4A208DA6D14E2995115A701BC6B8C9">
						<Properties>
							<string name="Name">mMove</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBXC87F348C06334841A5752816591D43D7">
						<Properties>
							<string name="Name">type</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBXC415781073B14C71BB1B36B4A3C6BDC3">
						<Properties>
							<string name="Name">gui</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX231144DA5D144CC0BE4B6BDD664C43ED">
						<Properties>
							<string name="Name">joystick</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXC0C7F7EE09A1487FA93AA61D85882980">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Input</string>
							<string name="ScriptGuid">{A6200938-E5C7-43DA-800D-4169A39C2ED9}</string>
							<ProtectedString name="Source"><![CDATA[modtable = {}
local cc = script.Parent
plr = game.Players[script.Parent.Name]
Mouse = {}
Mouse.hit = CFrame.new()
Mouse.target = nil
Mouse.origin = CFrame.new()
cc.Mouse.OnServerEvent:Connect(function(p, m1, m2, m3)
	if p ~= plr then return end
	modtable.MouseCframe = m1
	modtable.MouseTarget = m2
	modtable.MouseOrigin = m3
end)
local mkd = Instance.new("BindableEvent", cc)
local mku = Instance.new("BindableEvent", cc)
cc.KeyDown.OnServerEvent:Connect(function(p, k) if p ~= plr then return end mkd:Fire(k) end)
cc.KeyUp.OnServerEvent:Connect(function(p, k) if p ~= plr then return end mku:Fire(k) end)
modtable.KeyDown = mkd.Event
modtable.KeyUp = mku.Event
modtable.Button1Down = Instance.new("BindableEvent",cc)
modtable.Button1Up = Instance.new("BindableEvent",cc)
modtable.Button2Down = Instance.new("BindableEvent",cc)
modtable.Button2Up = Instance.new("BindableEvent",cc)
cc.b1d.OnServerEvent:Connect(function(p)
	if p ~= plr then return end
	modtable.Button1Down:Fire()
end)
cc.b1u.OnServerEvent:Connect(function(p)
	if p ~= plr then return end
	modtable.Button1Up:Fire()
end)
cc.b2d.OnServerEvent:Connect(function(p)
	if p ~= plr then return end
	modtable.Button2Down:Fire()
end)
cc.b2u.OnServerEvent:Connect(function(p)
	if p ~= plr then return end
	modtable.Button2Up:Fire()
end)
Camera = {}
modtable.CameraCframe = CFrame.new()
local mm = Instance.new("BindableEvent", cc)
local mi = Instance.new("BindableEvent", cc)
cc.Camera.OnServerEvent:Connect(function(p,val) if p ~= plr then return end modtable.CameraCframe = val end)
local ms = true
cc.mMove.OnServerEvent:Connect(function(p) if p ~= plr then return end ms = 1 end)
cc.mIdle.OnServerEvent:Connect(function(p) if p ~= plr then return end ms = 0 end)
local function mousem() 
	if ms == 1 then
		mm:Fire()
	elseif ms == 0 then
		mi:Fire()
	end
end
game:GetService('RunService').Heartbeat:Connect(mousem)
modtable.MouseMove = mm.Event
modtable.MouseIdle = mi.Event
local chat = Instance.new("BindableEvent", cc)
cc.Chat.OnServerEvent:Connect(function(p, msg) if p ~= plr then return end chat:Fire(msg) end)
modtable.Chatted = chat.Event
modtable.Type = nil
modtable.IsInGui = false
cc.gui.OnServerEvent:Connect(function(p,gui)
	if p ~= plr then return end
	modtable.IsInGui = gui
end)
cc.type.OnServerEvent:Connect(function(p,type1)
	if p ~= plr then return end
	modtable.Type = type1
	for i,v in ipairs(type1) do
			print(v)
	end
end)
modtable.JoyStick1 = nil
modtable.JoyStick2 = nil
cc.joystick.OnServerEvent:Connect(function(p,joy1,joy2)
	if p ~= plr then return end
	modtable.JoyStick1 = joy1
	modtable.JoyStick2 = joy2
end)


return modtable

--[[
## DEFINITIONS
The term, "StormDirus" can be defined in two ways:
1. The account holder of the Github account, that can be found at this URL:
https://github.com/StormDirus

2. The account holder of the Roblox account, that can be found at this URL:
https://www.roblox.com/users/49946095/profile

The term, "Repository" is the Github repository held in this URL:
https://github.com/StormDirus/DirusEngine



## LICENSE AGREEMENT
Copyright (c) 2019 StormDirus
This work may be distributed and/or modified under the
conditions of the LaTeX Project Public License, either version 1.3
of this license or (at your option) any later version.
The latest version of this license is in
http://www.latex-project.org/lppl.txt 
and version 1.3 or later is part of all distributions of LaTeX version 2005/12/01 or later.
This work has the LPPL maintenance status 'maintained'.
The Current Maintainer of this work is StormDirus.
--]]]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
		</Item>
		<Item class="Configuration" referent="RBX3546ABB1486647DE9BA047A33DC977B5">
			<Properties>
				<string name="Name">ServerScriptService</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Script" referent="RBX1B2B8ABB682C4049A53C43308BE32436">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">DirusEngine</string>
					<string name="ScriptGuid">{27DA4269-0E7F-4180-BC23-7FD7706535E6}</string>
					<ProtectedString name="Source"><![CDATA[game.Players.PlayerAdded:Connect(function(plr)
	local fold = game.ReplicatedStorage.PlayerFold.Folder:Clone()
	fold.Name = plr.Name
	fold.Parent = game.ReplicatedStorage.Events.Players
end)
engine = require(script.Main)

--[[
## DEFINITIONS
The term, "StormDirus" can be defined in two ways:
1. The account holder of the Github account, that can be found at this URL:
https://github.com/StormDirus

2. The account holder of the Roblox account, that can be found at this URL:
https://www.roblox.com/users/49946095/profile

The term, "Repository" is the Github repository held in this URL:
https://github.com/StormDirus/DirusEngine



## LICENSE AGREEMENT
Copyright (c) 2019 StormDirus
This work may be distributed and/or modified under the
conditions of the LaTeX Project Public License, either version 1.3
of this license or (at your option) any later version.
The latest version of this license is in
http://www.latex-project.org/lppl.txt 
and version 1.3 or later is part of all distributions of LaTeX version 2005/12/01 or later.
This work has the LPPL maintenance status 'maintained'.
The Current Maintainer of this work is StormDirus.
--]]
]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX45688EE3EE8D4F62B3AEBB15752B4536">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Main</string>
						<string name="ScriptGuid">{9BAD9C1F-C5E4-4BB1-8F94-94A921239C74}</string>
						<ProtectedString name="Source"><![CDATA[modtable = {}
for i,v in pairs(script:GetChildren()) do
	modtable[v.Name] = require(v)
end
return modtable

--[[
## DEFINITIONS
The term, "StormDirus" can be defined in two ways:
1. The account holder of the Github account, that can be found at this URL:
https://github.com/StormDirus

2. The account holder of the Roblox account, that can be found at this URL:
https://www.roblox.com/users/49946095/profile

The term, "Repository" is the Github repository held in this URL:
https://github.com/StormDirus/DirusEngine



## LICENSE AGREEMENT
Copyright (c) 2019 StormDirus
This work may be distributed and/or modified under the
conditions of the LaTeX Project Public License, either version 1.3
of this license or (at your option) any later version.
The latest version of this license is in
http://www.latex-project.org/lppl.txt 
and version 1.3 or later is part of all distributions of LaTeX version 2005/12/01 or later.
This work has the LPPL maintenance status 'maintained'.
The Current Maintainer of this work is StormDirus.
--]]

]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX1F15EACF94C1410FB0FE1468969CD536">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">PlayerLib</string>
							<string name="ScriptGuid">{D45DCC4D-D527-4DC5-A1DE-9473E70F89C8}</string>
							<ProtectedString name="Source"><![CDATA[modtable = {}
game.ReplicatedStorage.Events.Players.ChildAdded:Connect(function(obj)
	modtable[obj.Name] = {}
	modtable[obj.Name].Input = require(obj.Input)
	game.Players.PlayerRemoving:Connect(function(plr)
		if not obj then return end
		if plr.Name == obj.Name then
			obj:Remove()
			modtable[obj.Name] = nil
		end
	end)
	while wait(1) do
		if modtable[obj.Name] == nil then break end
		modtable[obj.Name].Friends = {}
		local page = game.Players:GetFriendsAsync(game.Players:GetUserIdFromNameAsync(obj.Name))
		local num = 1
		repeat
			local table1 = {}
			table1.Id = page:GetCurrentPage().Id
			table1.Name = page:GetCurrentPage().Username
			table1.Online = page:GetCurrentPage().IsOnline
			modtable[obj.Name].Friends[num] = table1
			num = num + 1
			if page.IsFinished ~= true then
				page:AdvanceToNextPageAsync()
			end
		until page.IsFinished == true
	end
end)
return modtable

--[[
## DEFINITIONS
The term, "StormDirus" can be defined in two ways:
1. The account holder of the Github account, that can be found at this URL:
https://github.com/StormDirus

2. The account holder of the Roblox account, that can be found at this URL:
https://www.roblox.com/users/49946095/profile

The term, "Repository" is the Github repository held in this URL:
https://github.com/StormDirus/DirusEngine



## LICENSE AGREEMENT
Copyright (c) 2019 StormDirus
This work may be distributed and/or modified under the
conditions of the LaTeX Project Public License, either version 1.3
of this license or (at your option) any later version.
The latest version of this license is in
http://www.latex-project.org/lppl.txt 
and version 1.3 or later is part of all distributions of LaTeX version 2005/12/01 or later.
This work has the LPPL maintenance status 'maintained'.
The Current Maintainer of this work is StormDirus.
--]]
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXFEEA8F55F67A45758DA354269844A23E">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">InstanceLib</string>
							<string name="ScriptGuid">{9DF737E4-2A93-420B-B395-1D58145C2CD4}</string>
							<ProtectedString name="Source"><![CDATA[local modtable = {}
valuelib = require(script.Parent.ValueLib)
function modtable:GetAncestors(obj)
	if obj.Parent then
		local a = obj.Parent
		local b = {}
		repeat
			table.insert(b,a)
			a = a.Parent
		until a == nil
		return b
	end
end
function modtable:FindFirstChildWithFunc(obj,func)
	for i,v in ipairs(obj:GetChildren()) do
		if func(v) == true then
			return v
		end
	end
end
function modtable:FindFirstDescendantWithFunc(obj,func)
	for i,v in ipairs(obj:GetDescendants()) do
		if func(v) == true then
			return v
		end
	end
end
function modtable:FindFirstAncestorWithFunc(obj,func)
	for i,v in ipairs(modtable:GetAncestors(obj)) do
		if func(v) == true then
			return v
		end
	end
end
function modtable:GetChildrenWithFunc(obj,func)
	local tab = {}
	for i,v in ipairs(obj:GetChildren()) do
		if func(v) == true then
			table.insert(tab,v)
		end
	end
	return tab
end
function modtable:GetDescendantsWithFunc(obj,func)
	local tab = {}
	for i,v in ipairs(obj:GetDescendants()) do
		if func(v) == true then
			table.insert(tab,v)
		end
	end
	return tab
end
function modtable:GetAncestorsWithFunc(obj,func)
	local tab = {}
	for i,v in ipairs(modtable:GetAncestors()) do
		if func(v) == true then
			table.insert(tab,v)
		end
	end
	return tab
end
function modtable:WaitForDescendantWithFunc(obj,func,time1)
	for i,v in ipairs(obj:GetDescendants()) do
		if func(v) == true then
			return v
		end
	end
	local eve = Instance.new("BindableEvent",script.Parent.Parent.TempObjs)
	local func1 = obj.DescendantAdded:Connect(function(obj2)
		for i,v in ipairs(obj:GetDescendants()) do
			if func(v) == true then
				eve:Fire(v)
				eve:Destroy()
			end
		end
	end)
	local val = eve.Event:wait(time1)
	func1:disconnect()
	return val
end
function modtable:WaitForChildWithFunc(obj,func,time1)
	for i,v in ipairs(obj:GetChildren()) do
		if func(v) == true then
			return v
		end
	end
	local eve = Instance.new("BindableEvent",script.Parent.Parent.TempObjs)
	local func1 = obj.ChildAdded:Connect(function(obj2)
		for i,v in ipairs(obj:GetDescendants()) do
			if func(v) == true then
				eve:Fire(v)
				eve:Destroy()
			end
		end
	end)
	local val = eve.Event:wait(time1)
	func1:disconnect()
	return val
end
function modtable:WaitForAncestorWithFunc(obj,func,time1)
	for i,v in ipairs(obj:GetDescendants()) do
		if func(v) == true then
			return v
		end
	end
	local eve = Instance.new("BindableEvent",script.Parent.Parent.TempObjs)
	local func1 = obj.AncestryChanged():Connect(function(obj2)
		for i,v in ipairs(modtable:GetAncestors(obj)) do
			if func(v) == true then
				eve:Fire(v)
				eve:Destroy()
			end
		end
	end)
	local val = eve.Event:wait(time1)
	func1:disconnect()
	return val
end
function modtable:GetInstancesWithFunc(obj,func)
	local tab = {}
	for i,v in ipairs(valuelib:GetIndex()) do
		if func(v) == true then
			table.insert(tab,v)
		end
	end
	return tab
end
function modtable.Create(objclass,parent,param1,param2)
	local obj = Instance.new(objclass,parent)
	if param1 then
		for i,v in ipairs(param1) do
			obj[v] = param2[i]
		end
	end
	return obj
end




return modtable

--[[
## DEFINITIONS
The term, "StormDirus" can be defined in two ways:
1. The account holder of the Github account, that can be found at this URL:
https://github.com/StormDirus

2. The account holder of the Roblox account, that can be found at this URL:
https://www.roblox.com/users/49946095/profile

The term, "Repository" is the Github repository held in this URL:
https://github.com/StormDirus/DirusEngine



## LICENSE AGREEMENT
Copyright (c) 2019 StormDirus
This work may be distributed and/or modified under the
conditions of the LaTeX Project Public License, either version 1.3
of this license or (at your option) any later version.
The latest version of this license is in
http://www.latex-project.org/lppl.txt 
and version 1.3 or later is part of all distributions of LaTeX version 2005/12/01 or later.
This work has the LPPL maintenance status 'maintained'.
The Current Maintainer of this work is StormDirus.
--]]
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX0D50E402820B43A5826FB7980B12C209">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ValueLib</string>
							<string name="ScriptGuid">{2A75F0B2-AF76-4B17-8A65-CB93BB101E72}</string>
							<ProtectedString name="Source"><![CDATA[modtable = {}
Index = {}
Index[1] = game
local indexnum = 1
for i,v in ipairs(game:GetDescendants()) do
	indexnum = indexnum + 1
	Index[indexnum] = v
end
game.DescendantAdded:Connect(function(obj)
	indexnum = indexnum + 1
	Index[indexnum] = obj
end)
function modtable:GetUserDataId(obj)
	for i,v in ipairs(Index) do
		if v == obj then
			return i
		end
	end
end
function modtable:GetIndex()
	return Index
end
function modtable:GetUserDataFromId(num)
	if Index[num] then
		return Index[num]
	end
end
function modtable:CreateFilteredTableClone(tab,func)
	local tab2 = {}
	for i,v in ipairs(tab) do
		if func(v) == true then
			table.insert(tab2,v)
		end
	end
	return tab2
end
function modtable.TableContains(tab,func)
	if tab then
		for i,v in ipairs(tab) do
			if func(v) == true then
				return i
			end
		end
	else
		return nil
	end
end	
return modtable

--[[
## DEFINITIONS
The term, "StormDirus" can be defined in two ways:
1. The account holder of the Github account, that can be found at this URL:
https://github.com/StormDirus

2. The account holder of the Roblox account, that can be found at this URL:
https://www.roblox.com/users/49946095/profile

The term, "Repository" is the Github repository held in this URL:
https://github.com/StormDirus/DirusEngine



## LICENSE AGREEMENT
Copyright (c) 2019 StormDirus
This work may be distributed and/or modified under the
conditions of the LaTeX Project Public License, either version 1.3
of this license or (at your option) any later version.
The latest version of this license is in
http://www.latex-project.org/lppl.txt 
and version 1.3 or later is part of all distributions of LaTeX version 2005/12/01 or later.
This work has the LPPL maintenance status 'maintained'.
The Current Maintainer of this work is StormDirus.
--]]
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX584BF534F85F42EAB7B67DEE0B9A35DF">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">CharacterLib</string>
							<string name="ScriptGuid">{02F4B997-BA4A-478A-8295-51E3C7BE2D89}</string>
							<ProtectedString name="Source"><![CDATA[modtable = {}
inst = require(script.Parent.InstanceLib)
pathfinddebounce = {}
pathfindingcache = {}
animcache = {}
animcache.hums = {}
index = require(script.Parent.ValueLib)
function modtable:GetPlayerFromObj(obj)
	if not game.Players:GetPlayerFromCharacter(obj) then
		local obj2 = inst:FindFirstAncestorWithFunc(obj,function(obj1) if game.Players:GetPlayerFromCharacter(obj1) then return true end end)
		if obj2 then
			local val = game.Players:GetPlayerFromCharacter(obj2)
			return val
		end
	else
		local val = game.Players:GetPlayerFromCharacter(obj)
		return val
	end
end
function modtable:GetHumanoidFromPlayer(plr)
	local char = plr.Character
	if char then
		local hum = inst:FindFirstDescendantWithFunc(char,function(obj1) if obj1:IsA("Humanoid") then return true end end)
		if hum then return hum end
	end
end
	function modtable:StartPathFind(hum, despoint)
		local indexnum = index:GetUserDataId(hum)
		if not pathfinddebounce[indexnum] then
			pathfinddebounce[indexnum] = 0
		end
		if pathfinddebounce[indexnum] == 1 then return end
		if pathfindingcache[indexnum] then
			pathfindingcache[indexnum].isdone = 1
			repeat game:GetService("RunService").Heartbeat:wait() until pathfindingcache[indexnum] == nil
			pathfindingcache[indexnum] = {}
			pathfindingcache[indexnum].isdone = 0
		else
			pathfindingcache[indexnum] = {}
			pathfindingcache[indexnum].isdone = 0
		end
		pathfinddebounce[indexnum] = 1
		if pcall(function() return despoint.Position end) then
			despoint = despoint.Position
		end
		local PathfindingService = game:GetService("PathfindingService")
    	local connect = {}
    	 
		local path = PathfindingService:CreatePath()
    	local waypoints
    	local currentWaypointIndex
    	
		local function waypointcheck(num1, num2)
			if CFrame.new(hum.RootPart.Position,num1).LookVector == CFrame.new(num1,num2).LookVector then
				return 1
			else
				return 0
			end
		end
    	
		local function followPath()
			path = PathfindingService:CreatePath()
    		path:ComputeAsync(hum.RootPart.Position, despoint)
    		waypoints = {}
    		if path.Status == Enum.PathStatus.Success then
    			waypoints = path:GetWaypoints()
    			currentWaypointIndex = 1
				repeat
				currentWaypointIndex = currentWaypointIndex + 1
				if not waypoints[currentWaypointIndex + 2] then
					break
				end
			until waypointcheck(waypoints[currentWaypointIndex].Position,waypoints[currentWaypointIndex + 1].Position) == 0
    			hum:MoveTo(waypoints[currentWaypointIndex].Position)
				if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then
					hum.Jump = true
				end
				pathfinddebounce[indexnum] = 0
    		else
    			hum:MoveTo(hum.RootPart.Position)
				pathfinddebounce[indexnum] = 0
    		end
   	 end
   	  
    	 
    	connect["onPathBlocked"] = path.Blocked:Connect(followPath)
    	 
    	connect["onWaypointReached"] = hum.MoveToFinished:Connect(followPath)
     	local function check()
			if pathfindingcache[indexnum].isdone == 1 then
				pathfinddebounce[indexnum] = 0
				connect["onPathBlocked"]:disconnect()
				connect["onWaypointReached"]:disconnect()
				pathfindingcache[indexnum] = nil
				connect["check"]:disconnect()
			end
		end
		connect["check"] = game:GetService("RunService").Heartbeat:Connect(check)
    	followPath()
	end
game:GetService("RunService").Heartbeat:Connect(function()
	for i,hum in ipairs(inst:GetDescendantsWithFunc(workspace,function(funcobj) if funcobj:IsA("Humanoid") or funcobj:IsA("AnimationController") then return true end end)) do
		local indexnum = index:GetUserDataId(hum)
		if animcache.hums[indexnum] then
			animcache.hums[indexnum].anims = hum:GetPlayingAnimationTracks()
		else
			animcache.hums[indexnum] = {}
		end
	end
end)
function modtable:CanPathFind(hum, despoint)
	if pcall(function() return despoint.Position end) then
		despoint = despoint.Position
	end
	local PathfindingService = game:GetService("PathfindingService")
	local path = PathfindingService:CreatePath()
    path:ComputeAsync(hum.RootPart.Position, despoint)
	return path.Status
end
function modtable:StopPathFind(hum)
	local indexnum = index:GetUserDataId(hum)
	if pathfindingcache[indexnum] then
		pathfindingcache[indexnum].isdone = 1
		repeat game:GetService("RunService").Heartbeat:wait() until pathfindingcache[indexnum] == nil
	end
end
function modtable:PlayAnim(hum,anim,speed,looped,weight,fade)
	if hum then
		if hum:IsA("Humanoid") or hum:IsA("AnimationController") then
		else
			local obj2 = inst.FindFirstDescendantWithFunc(hum,function(obj1) if obj1:IsA("Humanoid") or obj1:IsA("AnimationController") then return true end end)
			if obj2 then
				hum = obj2
			else
				if hum:FindFirstChild("HumanoidRootPart") then
					hum = Instance.new("Humanoid",hum)
				else
					hum = Instance.new("AnimationController",hum)
				end
			end
		end
		
	else
		error("Missing paramater.")
	end
	local anim2
	if string.find(tostring(anim),"rbxassetid://") or string.find(tostring(anim),"http://www.roblox.com/asset/?id=") then
		anim = inst.Create("Animation",game,{"AnimationId"},{anim})
		anim2 = hum:LoadAnimation(anim)
	elseif pcall(function() return anim.AnimationId end) then
		anim = anim.AnimationId
		anim = inst.Create("Animation",nil,{"AnimationId"},{tostring(anim)})
		anim2 = hum:LoadAnimation(anim)
	else
		anim2 = hum:LoadAnimation("rbxassetid://" ..(tostring(anim)))
	end
	if not anim2 then return end
	anim2.Looped = looped
	anim2:Play(fade,weight,speed)
	return anim2
end
function modtable:NewAnim(hum)
	local anim2
	if string.find(tostring(anim),"rbxassetid://") or string.find(tostring(anim),"http://www.roblox.com/asset/?id=") then
		anim = inst.Create("Animation",game,{"AnimationId"},{anim})
		anim2 = hum:LoadAnimation(anim)
	elseif pcall(function() return anim.AnimationId end) then
		anim = anim.AnimationId
		anim = inst.Create("Animation",nil,{"AnimationId"},{tostring(anim)})
		anim2 = hum:LoadAnimation(anim)
	else
		anim2 = hum:LoadAnimation("rbxassetid://" ..(tostring(anim)))
	end
	if not anim2 then return end
	return anim2
	end
function modtable:EditAnim(anim,speed,weight,fade,looped)
	if speed then
		anim:AdjustSpeed(speed)
	end
	if weight then
		anim:AdjustWeight(weight,fade)
	end
	if looped ~= nil then
		anim.Looped = looped
	end
end
DmgEventSub = Instance.new("BindableEvent",script.Parent.Parent.TempObjs)
modtable.DmgEvent = DmgEventSub.Event
modtable.DmgCache = {}
function modtable:Damage(hum,damager,dmg)
	hum.Health = hum.Health - dmg
	local inval = index:GetUserDataId(hum)
	modtable.DmgCache[inval] = damager
	modtable.DmgEventSub:Fire(hum,damager,dmg)
end

return modtable

--[[
## DEFINITIONS
The term, "StormDirus" can be defined in two ways:
1. The account holder of the Github account, that can be found at this URL:
https://github.com/StormDirus

2. The account holder of the Roblox account, that can be found at this URL:
https://www.roblox.com/users/49946095/profile

The term, "Repository" is the Github repository held in this URL:
https://github.com/StormDirus/DirusEngine



## LICENSE AGREEMENT
Copyright (c) 2019 StormDirus
This work may be distributed and/or modified under the
conditions of the LaTeX Project Public License, either version 1.3
of this license or (at your option) any later version.
The latest version of this license is in
http://www.latex-project.org/lppl.txt 
and version 1.3 or later is part of all distributions of LaTeX version 2005/12/01 or later.
This work has the LPPL maintenance status 'maintained'.
The Current Maintainer of this work is StormDirus.
--]]
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX3D8E2DE1D8A94CC9868EB0B4A7706479">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">SandboxLib</string>
							<string name="ScriptGuid">{C3FD1B82-614D-4E1F-935A-30264823EE43}</string>
							<ProtectedString name="Source"><![CDATA[valmod = require(script.Parent.ValueLib)
inst = require(script.Parent.InstanceLib)
local modtable = {}

modtable.Hidden = function(obj) --Defines what Userdatas will be 'Hidden', which means they can't be accessed, changed, or even detected.
	if obj == script.Parent.Parent or obj:IsDescendantOf(script.Parent.Parent) then return true
	elseif obj == game.ReplicatedStorage.Events or obj:IsDescendantOf(game.ReplicatedStorage.Events) then return true
	elseif obj == game.ReplicatedStorage.PlayerFold or obj:IsDescendantOf(game.ReplicatedStorage.PlayerFold) then return true
	elseif obj.ClassName == "LocalScript" and obj.Name == "PlrProbe" then return true
	end
end

modtable.ReadOnly = function(obj) --Defines what Userdatas will be 'Read-Only', which means the data can be read but not edited.
	
end

modtable.Protect = function(obj) --Defines what Userdatas will be 'Protected', which means they can't be destroyed
	if not pcall(function() return obj.IsA end) then return end
	if obj.ClassName == "Player" then
		return true
	end
end

modtable.Methods1 = {
	destroy = true,
	remove = true,
	clearallchildren = true,
	getchildren = true,
	getservice = true,
}
modtable.Methods2 = {
	destroy = function(obj)
		if valmod.TableContains(obj:GetDescendants(), function(obj1) if modtable.Hidden(obj1) or modtable.Protect(obj1) or modtable.ReadOnly(obj1) then return true end end) and b:lower() == "parent" then return error("Userdata contains hidden, protected, and/or read-only Userdata(s).") end
		if modtable.ReadOnly(obj) then return error("Userdata is read-only.") end
		if modtable.Protect(obj) then return error("Userdata is protected.") end
		obj:Destroy()
	end,
	remove = function(obj)
		if valmod.TableContains(obj:GetDescendants(), function(obj1) if modtable.Hidden(obj1) or modtable.Protect(obj1) or modtable.ReadOnly(obj1) then return true end end) and b:lower() == "parent" then return error("Userdata contains hidden, protected, and/or read-only Userdata(s).") end
		if modtable.ReadOnly(obj) then return error("Userdata is read-only.") end
		if modtable.Protect(obj) then return error("Userdata is protected.") end
		obj:Remove()
	end,
	clearallchildren = function(obj)
		for i,v in pairs(obj:GetChildren()) do
			if not modtable.Protect(obj) and not modtable.ReadOnly(obj) and not modtable.Hidden(obj) then 
				obj:Remove()
			end
		end
	end,
	getchildren = function(obj)
		local table1 = inst:GetChildrenWithFunc(obj,function(obj) if not modtable.Hidden then return true end end) 
		local table2 = {}
		for i,v in table1 do
			table2[i] = modtable.Wrap(v)
		end
		return table2
	end,
	getservice = function(stringy)
		if pcall(function() return stringy.IsA end) then return nil end
		if stringy:lower() == "insertservice" then return error("InsertService is not supported.") end
		if pcall(function() return game:GetService(stringy).IsA end) then
			return modtable.Wrap(game:GetService(stringy))
		else
			return modtable.Wrap(game:GetService(stringy))
		end
	end,
}
modtable.Wrap = function(obj) --The actual sandboxing function, it sandboxes the Userdatas so the metamethods can't break the sandbox, its the most important part.
	if not modtable.Hidden(obj) and not valmod.TableContains(inst:GetAncestors(obj),function(obj1) if modtable.Hidden(obj1) then return true end end) then
		local nobj = newproxy(true)
		getmetatable(nobj).__index = function(a,b)
			if modtable.Methods1[b:lower()] then
				return modtable.Methods2[b:lower()](obj)
			end
			if pcall(function() return obj[b].IsA end) then
				return modtable.Wrap(obj[b])
			else
				return modtable[b]
			end
			return nil
		end
		getmetatable(nobj).__newindex = function(a,b,c)
			if modtable.Protect(obj) and b:lower() == "parent" then return error("Userdata is protected.") end
			if modtable.ReadOnly(obj) then return error("Userdata is read-only.") end
			if valmod.TableContains(obj:GetDescendants(), function(obj1) if modtable.Hidden(obj1) or modtable.Protect(obj1) or modtable.ReadOnly(obj1) then return true end end) and b:lower() == "parent" then return error("Userdata contains hidden, protected, and/or read-only Userdata(s).") end
			obj[b] = c
		end
		getmetatable(nobj).__tostring = obj.Name or tostring(obj)
		getmetatable(nobj).__metatable = "This metatable is sandboxed."
		return nobj
	else
		return nil
	end
end
return modtable
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX2A896BAABCFD4B1B8D1677CD4E18A795">
					<Properties>
						<string name="Name">TempObjs</string>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="Configuration" referent="RBX1197153C4CBD4862B6C5E17F286E3152">
			<Properties>
				<string name="Name">ServerStorage</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Script" referent="RBX90ED6BA14FDA426FBF47266B6E047B54">
				<Properties>
					<bool name="Disabled">true</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Sandboxed_Script</string>
					<string name="ScriptGuid">{3957E7AC-F55A-4831-B0C2-2D73AE03F9F7}</string>
					<ProtectedString name="Source"><![CDATA[code = loadstring([[
	
]]) --Code goes inside the loadstring.
do --Begin sandboxing procces strictly on the 'code' function.
	sand = require(game.ServerScriptService.DirusEngine.Main).SandboxLib
	setfenv(code,{
		game = sand.Wrap(game),
		workspace = sand.Wrap(workspace),
		_G =  function()
			return error("Global values are not supported.")
		end,
		require = function()
			return error("Require is not supported.")
		end,
		setfenv = function()
			return error("Functions and script enviroments are locked.")
		end,
		getfenv = function()
			return error("Functions and script enviroments are locked.")
		end,
		Instance ={
        	new = function(a, b)
            	return sand.Wrap(Instance.new(a, b))
        	end
    	},
		loadstring = loadstring,
    	print = print,
    	error = error,
    	table = table,
    	pairs = pairs,
    	string = string,
	    ipairs = ipairs,
	    next = next,
	    os = os,
	    pcall = pcall,
	    rawequal = rawequal,
	    rawget = rawget,
	    rawset = rawset,
	    select = select,
	    setmetatable = setmetatable,
	    tonumber = tonumber,
	    tostring = tostring,
	    type = type,
	    unpack = unpack,
	    _VERSION = _VERSION,
	    xpcall = xpcall,
	    collectgarbage = collectgarbage,
	    assert = assert,
	    gcinfo = gcinfo,
	    coroutine = coroutine,
	    string = string,
	    table = table,
	    math = math,
	    delay = delay,
	    spawn = spawn,
	    tick = tick,
	    time = time,
	    UserSettings = UserSettings,
	    wait = wait,
	    warn = warn,
	    ypcall = ypcall,
	    settings = settings,
	})
end --Sandboxing finnished.
code() --Activate sandboxed code.

--[[
## DEFINITIONS
The term, "StormDirus" can be defined in two ways:
1. The account holder of the Github account, that can be found at this URL:
https://github.com/StormDirus

2. The account holder of the Roblox account, that can be found at this URL:
https://www.roblox.com/users/49946095/profile

The term, "Repository" is the Github repository held in this URL:
https://github.com/StormDirus/DirusEngine



## LICENSE AGREEMENT
Copyright (c) 2019 StormDirus
This work may be distributed and/or modified under the
conditions of the LaTeX Project Public License, either version 1.3
of this license or (at your option) any later version.
The latest version of this license is in
http://www.latex-project.org/lppl.txt 
and version 1.3 or later is part of all distributions of LaTeX version 2005/12/01 or later.
This work has the LPPL maintenance status 'maintained'.
The Current Maintainer of this work is StormDirus.
--]]
]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
	</Item>
</roblox>
