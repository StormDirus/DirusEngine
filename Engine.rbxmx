<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<Meta name="ExplicitAutoJoints">true</Meta>
	<External>null</External>
	<External>nil</External>
	<Item class="Folder" referent="RBX49D4F8BFBE284BCC84E1C7B8E6B490B5">
		<Properties>
			<string name="Name">Files</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Configuration" referent="RBXBCA08C24F6C44146921BEA637EE5D9E8">
			<Properties>
				<string name="Name">StarterPlayer</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Configuration" referent="RBX8487E8B9253B4098BE2680F5E0F016E5">
				<Properties>
					<string name="Name">StarterPlayerScripts</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="LocalScript" referent="RBX715CA42D71F54CCE9640F624DEE13EE8">
					<Properties>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">PlrProbe</string>
						<string name="ScriptGuid">{363317DE-ADDF-4422-BDD6-F5C3C442D97D}</string>
						<ProtectedString name="Source"><![CDATA[joy1 = {}
joy1.Delta = Vector3.new(0,0,0)
joy1.Position = Vector3.new(0,0,0)
joy2 = {}
joy2.Delta = Vector3.new(0,0,0)
joy2.Position = Vector3.new(0,0,0)
plr = game.Players.LocalPlayer
mouse = plr:GetMouse()
camera = workspace.CurrentCamera
cc = game.ReplicatedStorage.Events.Players:WaitForChild(plr.Name)
idle = 0
uis = game:GetService("UserInputService")
uis.InputChanged:Connect(function(input,gp)
	if input.KeyCode == Enum.KeyCode.Thumbstick1 then
		joy1.Delta = input.Delta
		joy1.Position = input.Position
	elseif input.KeyCode == Enum.KeyCode.Thumbstick2 then
		joy2.Delta = input.Delta
		joy2.Position = input.Position
	end
end)
uis.InputBegan:Connect(function(input, gpe)
	cc.KeyDown:FireServer(input.KeyCode)
end)
uis.InputEnded:Connect(function(input, gpe)
	cc.KeyUp:FireServer(input.KeyCode)
end)

mouse.Button1Down:Connect(function() cc.b1d:FireServer() end)
mouse.Button1Up:Connect(function() cc.b1u:FireServer() end)
mouse.Button2Down:Connect(function() cc.b2d:FireServer() end)
mouse.Button2Up:Connect(function() cc.b2d:FireServer() end)
mouse.Move:Connect(function() idle = 1 end)
mouse.Idle:Connect(function() idle = 0 end)
plr.Chatted:Connect(function(msg) cc.Chat:FireServer(msg) end)
tabinput = {}
cc.changestate.OnClientEvent:Connect(function(hum,state,bool)
	hum:SetStateEnabled(state,bool)
end)
while wait(1/30) do
	local gui
	if uis:GetFocusedTextBox() then
		gui = true
	else
		gui = false
	end
	cc.joystick:FireServer(joy1,joy2)
	tabinput = {Accelerometer = uis.AccelerometerEnabled,Gamepad = uis.GamepadEnabled,Gyroscope = uis.GyroscopeEnabled,Keyboard = uis.KeyboardEnabled,Modal = uis.ModalEnabled,Mouse = uis.MouseEnabled,Touch = uis.TouchEnabled,VR = uis.VREnabled}
	cc.gui:FireServer(gui)
	cc.type:FireServer(tabinput)
	cc.Mouse:FireServer(mouse.hit, mouse.target, mouse.origin)
	if idle == 1 then
		cc.mMove:FireServer()
	else
		cc.mIdle:FireServer()
	end
	cc.Camera:FireServer(camera.CFrame)
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="Configuration" referent="RBXF3472E626D6749169D84BEE5A5789069">
			<Properties>
				<string name="Name">ReplicatedStorage</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Folder" referent="RBXB0CE9C02C8D2468A93396AAF85E84F29">
				<Properties>
					<string name="Name">Events</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBXAD1CFC762A32441BBCB9CA7FB73246E9">
					<Properties>
						<string name="Name">Players</string>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXD5D7429F285D43589139AB6AD6F422A1">
				<Properties>
					<string name="Name">PlayerFold</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBXFDEB8CD858E944E894426FCA3ACD445E">
					<Properties>
						<string name="Name">Folder</string>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="RemoteEvent" referent="RBXE2279B036A624FE0A5AF11EBD0C1EEE4">
						<Properties>
							<string name="Name">Camera</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX1E35166CF0DA4091BCFA6E0546E33866">
						<Properties>
							<string name="Name">Chat</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX5A2ED0FEF6824E7F871292361BDE9F8E">
						<Properties>
							<string name="Name">KeyDown</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX8EDB2E01B6694ADA8A0BC36FD7135E52">
						<Properties>
							<string name="Name">KeyUp</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBXFAFACB026C1444359ABE9A07D100964F">
						<Properties>
							<string name="Name">Mouse</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX3FFFCA96FA064DBDB65837C0175BCA12">
						<Properties>
							<string name="Name">b1d</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBXBA433692712E4EE69C103DC1BA5DD0E2">
						<Properties>
							<string name="Name">b1u</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX9D066F1250294DC2996D84259F08CD53">
						<Properties>
							<string name="Name">b2d</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBXB4C2FE4CF7034341B3182ED902A18A07">
						<Properties>
							<string name="Name">b2u</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX8C16049F1153400E9DBFBEC59297FB6D">
						<Properties>
							<string name="Name">mIdle</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBXA847C3271B794234A771CBA125A0EAC2">
						<Properties>
							<string name="Name">mMove</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX5E666069BE704C2BA29B015682CBCAB6">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Input</string>
							<string name="ScriptGuid">{136C0D38-AF84-4D3D-B718-5E031657CB94}</string>
							<ProtectedString name="Source"><![CDATA[modtable = {}
local cc = script.Parent
plr = game.Players[script.Parent.Name]
Mouse = {}
Mouse.hit = CFrame.new()
Mouse.target = nil
Mouse.origin = CFrame.new()
cc.Mouse.OnServerEvent:Connect(function(p, m1, m2, m3)
	if p ~= plr then return end
	modtable.MouseCframe = m1
	modtable.MouseTarget = m2
	modtable.MouseOrigin = m3
end)
local mkd = Instance.new("BindableEvent", cc)
local mku = Instance.new("BindableEvent", cc)
cc.KeyDown.OnServerEvent:Connect(function(p, k) if p ~= plr then return end mkd:Fire(k) end)
cc.KeyUp.OnServerEvent:Connect(function(p, k) if p ~= plr then return end mku:Fire(k) end)
modtable.KeyDown = mkd.Event
modtable.KeyUp = mku.Event
Button1Down = Instance.new("BindableEvent",cc)
Button1Up = Instance.new("BindableEvent",cc)
Button2Down = Instance.new("BindableEvent",cc)
Button2Up = Instance.new("BindableEvent",cc)
cc.b1d.OnServerEvent:Connect(function(p)
	if p ~= plr then return end
	Button1Down:Fire()
end)
cc.b1u.OnServerEvent:Connect(function(p)
	if p ~= plr then return end
	Button1Up:Fire()
end)
cc.b2d.OnServerEvent:Connect(function(p)
	if p ~= plr then return end
	Button2Down:Fire()
end)
cc.b2u.OnServerEvent:Connect(function(p)
	if p ~= plr then return end
	Button2Up:Fire()
end)
modtable.Button1Down = Button1Down.Event
modtable.Button1Up = Button1Up.Event
modtable.Button2Down = Button2Down.Event
modtable.Button2Up = Button2Up.Event

Camera = {}
modtable.CameraCframe = CFrame.new()
local mm = Instance.new("BindableEvent", cc)
local mi = Instance.new("BindableEvent", cc)
cc.Camera.OnServerEvent:Connect(function(p,val) if p ~= plr then return end modtable.CameraCframe = val end)
local ms = true
cc.mMove.OnServerEvent:Connect(function(p) if p ~= plr then return end ms = 1 end)
cc.mIdle.OnServerEvent:Connect(function(p) if p ~= plr then return end ms = 0 end)
local function mousem() 
	if ms == 1 then
		mm:Fire()
	elseif ms == 0 then
		mi:Fire()
	end
end
game:GetService('RunService').Heartbeat:Connect(mousem)
modtable.MouseMove = mm.Event
modtable.MouseIdle = mi.Event
local chat = Instance.new("BindableEvent", script)
cc.Chat.OnServerEvent:Connect(function(p, msg) if p ~= plr then return end chat:Fire(msg) end)
modtable.Chatted = chat.Event
modtable.Type = nil
modtable.IsInGui = false
cc.gui.OnServerEvent:Connect(function(p,gui)
	if p ~= plr then return end
	modtable.IsInGui = gui
end)
cc.type.OnServerEvent:Connect(function(p,type1)
	if p ~= plr then return end
	modtable.Type = type1
	for i,v in ipairs(type1) do
			print(v)
	end
end)
modtable.JoyStick1 = nil
modtable.JoyStick2 = nil
cc.joystick.OnServerEvent:Connect(function(p,joy1,joy2)
	if p ~= plr then return end
	modtable.JoyStick1 = joy1
	modtable.JoyStick2 = joy2
end)


return modtable

]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBXB92A837B050F471BB7A1D305A4F0FE93">
						<Properties>
							<string name="Name">type</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX7D0B96C45DC2432A9F96ED42B20EFF8A">
						<Properties>
							<string name="Name">gui</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX32C643CD940A42288D8D7D216927DB51">
						<Properties>
							<string name="Name">joystick</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX5F521F2986D543108DB6651ECC24F787">
						<Properties>
							<string name="Name">changestate</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
		</Item>
		<Item class="Configuration" referent="RBX456326D221064C72A04025C7D7412208">
			<Properties>
				<string name="Name">ServerScriptService</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Script" referent="RBX280EFF9D894544D295218DF54E1443E1">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">DirusEngine</string>
					<string name="ScriptGuid">{4463D79A-1E08-402F-BFAD-0D0D3D641AF8}</string>
					<ProtectedString name="Source"><![CDATA[game.Players.PlayerAdded:Connect(function(plr)
	local fold = game.ReplicatedStorage.PlayerFold.Folder:Clone()
	fold.Name = plr.Name
	fold.Parent = game.ReplicatedStorage.Events.Players
end)
function code() end
require(script.Get,getfenv(code))
--[[

MIT License

Copyright (c) 2019 StormDirus

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

--]]]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX8BA35704C717482E82D0E42B4358AF1E">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">PlayerLib</string>
						<string name="ScriptGuid">{C0AB1CD7-AA76-472B-9983-CDCBE9C0E56E}</string>
						<ProtectedString name="Source"><![CDATA[modtable = {}
groupservice = game:GetService("GroupService")
httpserice = game:GetService("HttpService")
function getwebdata(link)
	local tab = {}
	local num = 1
	repeat
		local json = httpserice:GetAsync(link .."?page=" ..num)
		for i, v in pairs(httpserice:JSONDecode(json)) do
			tab[#tab + 1] = modtable.GetInfo(v.Id)
		end
		num = num + 1
	until #(httpserice:JSONDecode(httpserice:GetAsync(link .."?page=" ..num))) == 0
	return tab
end

function getgroups(id)
	local table1 = {}
	local groups = groupservice:GetGroupsAsync(id)
	for i,group1 in ipairs(groups) do
		local group2 = groupservice:GetGroupInfoAsync(group1.Id)
		local table2 = {
			Name = group2.Name,
			Id = group2.Id,
			Emblem = group2.EmblemUrl,
			Description = group2.Description,
			Roles = group2.Roles,
			PlayerPrimary = group1.IsPrimary,
			PlayerClan = group1.IsInClan,
			PlayerRank = group1.Rank,
			PlayerRole = group1.Role,
		}
		if group2.Owner then
			table2.Owner = modtable:GetInfo(group2.Owner.Id)
		end
		table1[i] = table2
	end
	return table1
end
function modtable.GetInfo(id)
	local ud = {}
	ud.GetName = function()
		return game.Players:GetNameFromUserIdAsync(id)
	end
	ud.Id = id
	ud.GetAppearance = function()
		return game.Players:GetCharacterAppearanceAsync(id)
	end
	ud.GetGroups = function()
		return getgroups(id)
	end
	ud.GetPlayerThumbnail = function(Type,Size)
		return game.Players:GetUserThumbnailAsync(id,Type,Size)
	end
	ud.GetFriends = function()
		return getwebdata("https://api.rprxy.xyz/users/" ..id .."/friends")
	end
	ud.CheckIfOnline = function()
		return (httpserice:JSONDecode(httpserice:GetAsync("https://api.rprxy.xyz/users" ..id))).IsOnline
	end
	return ud
end
game.ReplicatedStorage.Events.Players.ChildAdded:Connect(function(obj)
	modtable[obj.Name] = {}
	modtable[obj.Name].Input = require(obj.Input)
	modtable[obj.Name].Info = modtable.GetInfo(game.Players:GetUserIdFromNameAsync(obj.Name))
	game.Players.PlayerRemoving:Connect(function(plr)
		if not obj then return end
		if plr.Name == obj.Name then
			obj:Remove()
		end
	end)
end)
return modtable

]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX50A7C8B75836494895891247BB724BA8">
					<Properties>
						<string name="Name">TempObjs</string>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX0D7E217C9BAA4689B271BB3CD2B291B6">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Get</string>
						<string name="ScriptGuid">{BE6F0F3C-FCB1-45B9-B304-8A814C68143B}</string>
						<ProtectedString name="Source"><![CDATA[Index = {}
Index.Tab = {}
function Index.getunwrapped(np)
	if pcall(function() return np.__SandboxId end) then
		return Index.Tab[np.__SandboxId]
	end
end
Indexenv = {}
udnums = 0
Env1 = {}
Env1.Condition = {}
local conds = {}
function Env1.Condition.new(func)
	if type(func) ~= "function" then
		func = function() return true end
	end
	local np = newproxy(true)
	local meta = getmetatable(np)
	local tab = {}
	tab.Function = func
	tab["__SandboxType"] = "Condition"
	function tab.Cast(...)
		if pcall(function(...) return tab.Function(...) end) and tab.Function(...) then
			return true
		else
			return false
		end
	end
	meta.__index = function(a,b)
		if tab[b] then
			return tab[b]
		end
	end
	meta.__newindex = function(a,b,c)
		if b == "Function" then
			tab[b] = c
		end
	end
	meta.__eq = function(a,b)
		return np == b
	end
	meta.__tostring = function()
		return tostring(tab.Cast())
	end
	meta.__metatable = "This metatable is locked."
	conds[#conds + 1] = np
	return np
end

MetaIndex = {}
MetaIndex.Instance = {}
local function GetAncestors(obj)
	if obj.Parent then
		local a = obj.Parent
		local b = {}
		repeat
			b[#b + 1] = a
			a = a.Parent
		until a == nil
		local i = #b
		local tab = {}
		repeat
			tab[#tab + 1] = b[i]
			i = i - 1
		until i == 0
		return tab
	end
end
function MetaIndex.Instance:findfirstchild(inst,thing)
	if Index.getunwrapped(inst) then
		inst = Index.getunwrapped(inst)
	end
	local children = inst:GetChildren()
	if thing == nil then
		return children[1]
	elseif iscond(thing) then
		for i,v in next, children do
			if thing.Cast(wrap(v)) then
				return v
			end
		end
	elseif type(thing) == "string" then
		for i,v in next, children do
			if thing == (v.Name or tostring(v)) then
				return v
			end
		end
	elseif type(thing) == "number" then
		return children[thing]
	end
end
function MetaIndex.Instance:findfirstancestor(inst,thing)
	if Index.getunwrapped(inst) then
		inst = Index.getunwrapped(inst)
	end
	local children = GetAncestors(inst)
	if thing == nil then
		return children[1]
	elseif iscond(thing) then
		for i,v in next, children do
			if thing.Cast(wrap(v)) then
				return v
			end
		end
	elseif type(thing) == "string" then
		for i,v in next, children do
			if thing == (v.Name or tostring(v)) then
				return v
			end
		end
	elseif type(thing) == "number" then
		return children[thing]
	end
end
function MetaIndex.Instance:findfirstdescendant(inst,thing)
	if Index.getunwrapped(inst) then
		inst = Index.getunwrapped(inst)
	end
	local children = inst:GetDescendants()
	if thing == nil then
		return children[1]
	elseif iscond(thing) then
		for i,v in next, children do
			if thing.Cast(wrap(v)) then
				return v
			end
		end
	elseif type(thing) == "string" then
		for i,v in next, children do
			if thing == (v.Name or tostring(v)) then
				return v
			end
		end
	elseif type(thing) == "number" then
		return children[thing]
	end
end
function MetaIndex.Instance:getchildren(inst,thing)
	if Index.getunwrapped(inst) then
		inst = Index.getunwrapped(inst)
	end
	local children = inst:GetChildren()
	if thing == nil then
		return children
	elseif iscond(thing) then
		local tab = {}
		for i,v in next, children do
			if thing.Cast(wrap(v)) then
				tab[i] = v
			end
		end
		return tab
	elseif type(thing) == "string" then
		local tab = {}
		for i,v in next, children do
			if thing == (v.Name or tostring(v)) then
				tab[i] = v
			end
		end
		return tab
	elseif type(thing) == "number" then
		local tab = {}
		for i,v in next, children do
			if i < thing then
				tab[#tab + 1] = v
			end
		end
		return tab
	end
end
function MetaIndex.Instance:getancestors(inst,thing)
	if Index.getunwrapped(inst) then
		inst = Index.getunwrapped(inst)
	end
	local children = GetAncestors(inst)
	if thing == nil then
		return children
	elseif iscond(thing) then
		local tab = {}
		for i,v in next, children do
			if thing.Cast(wrap(v)) then
				tab[i] = v
			end
		end
		return tab
	elseif type(thing) == "string" then
		local tab = {}
		for i,v in next, children do
			if thing == (v.Name or tostring(v)) then
				tab[i] = v
			end
		end
		return tab
	elseif type(thing) == "number" then
		local tab = {}
		for i,v in next, children do
			if i < thing then
				tab[#tab + 1] = v
			end
		end
		return tab
	end
end
function MetaIndex.Instance:getdescendants(inst,thing)
	if Index.getunwrapped(inst) then
		inst = Index.getunwrapped(inst)
	end
	local children = inst:GetDescendants()
	if thing == nil then
		return children
	elseif iscond(thing) then
		local tab = {}
		for i,v in next, children do
			if thing.Cast(wrap(v)) then
				tab[i] = v
			end
		end
		return tab
	elseif type(thing) == "string" then
		local tab = {}
		for i,v in next, children do
			if thing == (v.Name or tostring(v)) then
				tab[i] = v
			end
		end
		return tab
	elseif type(thing) == "number" then
		local tab = {}
		for i,v in next, children do
			if i < thing then
				tab[#tab + 1] = v
			end
		end
		return tab
	end
end
function MetaIndex.Instance:waitforchild(inst,thing,time1)
	if Index.getunwrapped(inst) then
		inst = Index.getunwrapped(inst)
	end
	local children = inst:GetChildren()
	if thing == nil and children[1] then
		return children[1]
	elseif iscond(thing) then
		for i,v in next, children do
			if thing.Cast(wrap(v)) then
				return v
			end
		end
	elseif type(thing) == "string" then
		for i,v in next, children do
			if thing == (v.Name or tostring(v)) then
				return v
			end
		end
	elseif type(thing) == "number" and children[thing] then
		return children[thing]
	end
	local eve = Instance.new("BindableEvent",game.ServerScriptService.DirusEngine.TempObjs)
	local func1 = inst.ChildAdded:Connect(function(obj2)
		if thing == nil then
			eve:Fire(obj2)
			eve:Destroy()
		elseif iscond(thing) then
			if thing.Cast(wrap(obj2)) then
				eve:Fire(obj2)
				eve:Destroy()
			end
		elseif type(thing) == "string" then
			if thing == (obj2.Name or tostring(obj2)) then
				eve:Fire(obj2)
				eve:Destroy()
			end
		elseif type(thing) == "number" then
			children = inst:GetChildren()
			if children[thing] then
				eve:Fire(obj2)
				eve:Destroy()
			end
		end
	end)
	local val = eve.Event:wait(time1)
	func1:disconnect()
	if eve then eve:Destroy() end
	return val
end
function MetaIndex.Instance:waitfordescendant(inst,thing,time1)
	if Index.getunwrapped(inst) then
		inst = Index.getunwrapped(inst)
	end
	local children = inst:GetDescendants()
	if thing == nil and children[1] then
		return children[1]
	elseif iscond(thing) then
		for i,v in next, children do
			if thing.Cast(wrap(v)) then
				return v
			end
		end
	elseif type(thing) == "string" then
		for i,v in next, children do
			if thing == (v.Name or tostring(v)) then
				return v
			end
		end
	elseif type(thing) == "number" and children[thing] then
		return children[thing]
	end
	local eve = Instance.new("BindableEvent",game.ServerScriptService.DirusEngine.TempObjs)
	local func1 = inst.DescendantAdded:Connect(function(obj2)
		if thing == nil then
			eve:Fire(obj2)
			eve:Destroy()
		elseif iscond(thing) then
			if thing.Cast(wrap(obj2)) then
				eve:Fire(obj2)
				eve:Destroy()
			end
		elseif type(thing) == "string" then
			if thing == (obj2.Name or tostring(obj2)) then
				eve:Fire(obj2)
				eve:Destroy()
			end
		elseif type(thing) == "number" then
			children = inst:GetDescendants()
			if children[thing] then
				eve:Fire(obj2)
				eve:Destroy()
			end
		end
	end)
	local val = eve.Event:wait(time1)
	func1:disconnect()
	if eve then eve:Destroy() end
	return val
end
function MetaIndex.Instance:waitforancestor(inst,thing,time1)
	if Index.getunwrapped(inst) then
		inst = Index.getunwrapped(inst)
	end
	local children = GetAncestors(inst)
	if thing == nil and children[1] then
		return children[1]
	elseif iscond(thing) then
		for i,v in next, children do
			if thing.Cast(wrap(v)) then
				return v
			end
		end
	elseif type(thing) == "string" then
		for i,v in next, children do
			if thing == (v.Name or tostring(v)) then
				return v
			end
		end
	elseif type(thing) == "number" and children[thing] then
		return children[thing]
	end
	local eve = Instance.new("BindableEvent",game.ServerScriptService.DirusEngine.TempObjs)
	local func1 = inst.DescendantAdded:Connect(function(obj2)
		if thing == nil then
			eve:Fire(obj2)
			eve:Destroy()
		elseif iscond(thing) then
			if thing.Cast(wrap(obj2)) then
				eve:Fire(obj2)
				eve:Destroy()
			end
		elseif type(thing) == "string" then
			if thing == (obj2.Name or tostring(obj2)) then
				eve:Fire(obj2)
				eve:Destroy()
			end
		elseif type(thing) == "number" then
			children = GetAncestors(inst)
			if children[thing] then
				eve:Fire(obj2)
				eve:Destroy()
			end
		end
	end)
	local val = eve.Event:wait(time1)
	func1:disconnect()
	if eve then eve:Destroy() end
	return val
end
MetaIndex.RBXScriptSignal = {}
function MetaIndex.RBXScriptSignal:connect(a,func1,cond)
	if cond and type(cond) == "userdata" and iscond(cond) then
		local tab1 = {}
		local con = a:Connect(function(...) local a = vwrap({...}) if cond.Cast(unpack1(a)) then func1(unpack1(a)) end end)
		return con
	else
		local tab1 = {}
		local con = a:Connect(function(...) local a = vwrap({...}) func1(unpack1(a)) end)
		return con
	end
end
function MetaIndex.RBXScriptSignal:wait(inst,time1,cond)
			if cond and iscond(cond) then
				local eve = Instance.new("BindableEvent")
				local func1 = inst:Connect(function(...)
					local a = vwrap({...})
					if cond.Cast(unpack1(a)) then
						eve:Fire(unpack1(a))
						eve:Destroy()
					end
				end)
				local val = ({eve.Event:Wait(time1)})
				if eve then
					eve:Destroy()
				end
				func1:Disconnect()
				if #val ==0 then
					return nil
				end
				return unpack(val)
			else
				return inst:Wait(time1)
			end
end
MetaIndex.Region3 = {}
plrlib = require(script.Parent.PlayerLib)
function GetMaxMinCorners(cframe,size)
	local min = {}
	local max = {}
	local size = size/2
	local corn = {}
	for x = -1, 1, 2 do
		for y = -1, 1, 2 do
			for z = -1, 1, 2 do
				table.insert(corn, (cframe * CFrame.new(size * Vector3.new(x, y, z))).p)
			end
		end
	end
	for i,v in next,{Enum.NormalId.Right, Enum.NormalId.Top, Enum.NormalId.Back} do
		local norm = Vector3.FromNormalId(v)
		table.sort(corn, function(a, b) return a:Dot(norm) > b:Dot(norm) end)
		table.insert(min, corn[#corn])
		table.insert(max, corn[1])
	end;
	min, max = Vector3.new(min[1].x, min[2].y, min[3].z), Vector3.new(max[1].x, max[2].y, max[3].z)
	return {["Min"] = min, ["Max"] = max}
end
function iscond(cond)
	if type(cond) == "userdata" and pcall(function() if not cond.__SandboxType then return error("!") end end) and cond.__SandboxType == "Condition" then
		return true
	end
end
function unpack1(tab)
	if #tab == 0 then
		return nil
	end
	return unpack(tab)
end
function isenvwraped(env)
	for i,v in next, Indexenv do
		if rawequal(env,v) then
			return true
		end
	end
end
function envvalwrap1(val)
	if type(val) == "function" then
		if not isenvwraped(getfenv(val)) then
			envwrap(getfenv())
			return val
		end
		return val
	elseif type(val) == "table" then
		for i,v in next, val do
			val[i] = envvalwrap1(val[i])
		end
		return val
	end
	return vwrap(val)
end
function envvalwrap2(val)
	if type(val) == "function" and not isenvwraped(getfenv(val)) then
		return function(...)
			local a = vunwrap({...})
			return unpack1(vwrap({val(unpack1(a))}))
		end
	elseif type(val) == "table" then
		for i,v in next, val do
			val[i] = envvalwrap2(val[i])
		end
		return val
	end
	return vwrap(val)
	end
function envvalwrap3(val)
	if type(val) == "function" and not isenvwraped(getfenv(val)) then
		return function(...)
			return unpack1(vwrap({val(...)}))
		end
	elseif type(val) == "table" then
		for i,v in next, val do
			val[i] = envvalwrap2(val[i])
		end
		return val
	end
	return vwrap(val)
end
function envwrap(env)
	for i, v in next, env do
		env[i] = envvalwrap1(v)
	end
	if env.workspace then
		env.workspace = envvalwrap2(env.workspace)
	end
	if env.game then
		env.game = envvalwrap2(env.game)
	end
	if env.script then
		env.script = envvalwrap2(env.script)
	end
	if env.typeof then
		env.typeof = function(thing)
			if type(thing) == "userdata" and pcall(function() if not thing.__SandboxType then return error("!") end end) then
				return tostring(thing.__SandboxType)
			end
			return (envvalwrap2(env.typeof))(thing)
		end
	end
	if env.type then
		env.type = envvalwrap2(env.type)
	end
	if env.Region3 then
		env.Region3 = wrap(env.Region3)
	end
	if env.getmetatable then
		env.getmetatable = envvalwrap2(env.getmetatable)
	end
	if env.require then
		env.require = envvalwrap2(env.require)
	end
	if env.rawget then
		env.rawget = envvalwrap2(env.rawget)
	end
	if env.rawset then
		env.rawset = envvalwrap2(env.rawset)
	end
	if env.rawequal then
		env.rawequal = envvalwrap2(env.rawequal)
	end
	if env.setmetatable then
		env.setmetatable = envvalwrap2(env.setmetatable)
	end
	local instnew = {}
	instnew.new = function(a,b,c) 
		local obj = Instance.new(a,b)
		if c and type(c) == "table" then
			for i,v in next, c do
				obj[i] = v
			end
		end
		return obj
	end
	if env.Instance then
		if env.Instance == Instance then
			env.Instance = envvalwrap2(instnew)
		else
			env.Instance = envvalwrap2(env.Instance)
		end
	end
	for i,v in next, Env1 do
		env[i] = wrap(v)
	end
	if not isenvwraped(env) then
		Indexenv[#Indexenv + 1] = env
	end
end
function vunwrap(val)
		val = val
		local typ = type(val)
		local typ2 = typeof(val)
		if val == nil then
			return nil
		elseif Index.getunwrapped(val) then
			local a = Index.getunwrapped(val)
			return a
		elseif typ == "table" then
			local tab2 = {}
			for i,v in next, val do
				tab2[i] = vunwrap(v)
			end
			return tab2
		else
			return val
		end
end
function vwrap(val)
	val = val
	local typ = type(val)
	local typ2 = typeof(val)
	if typ == "table" then
		for i,v in next, val do
			val[i] = vwrap(val[i])
		end
		return val
	elseif typ == "userdata" and MetaIndex[typ2] then
		if Index.getunwrapped(val) then
			return val
		end
		return wrap(val)
	elseif typ2 == "userdata" and iscond(val) then
		if Index.getunwrapped(val) then
			return val
		end
		return wrap(val)
	elseif typ2 == "Region3" then
		if Index.getunwrapped(val) then
			return val
		end
		return wrap(val)
	else
		return val
	end
end
function wrap(ud)
	if Index.getunwrapped(ud) then
		return ud
	end
	local nud = newproxy(true)
	local meta = getmetatable(nud)
	local udnum = nil
	meta.__index = function(a,b)
		if iscond(ud) then
			return ud[b]
		end
		if MetaIndex[typeof(ud)] and MetaIndex[typeof(ud)][b:lower()] then
			return function(...) local c = vwrap({MetaIndex[typeof(ud)][b:lower()](ud,...)}) return unpack1(c) end
		end
		if b == "__SandboxId" then
			return udnum
		elseif b == "BreakJoints" and typeof(ud) == "Instance" and ud.ClassName == "Humanoid" then
			return function()
				if not ud.RootPart then return end
				local tab = {}
				local tab2 = {}
				local istracked = (function(val)
					for i,v in next, tab do
						if v == val then return true end
					end
				end)
				local istracked2 = (function(val)
					for i,v in next, tab2 do
						if v == val then return true end
					end
				end)
				local function track(obj)
					tab2[#tab2 + 1] = obj
					for i,v in next, obj:GetDescendants() do
						if v:IsA("JointInstance") and v.Part0 == obj and not istracked(v) then
							tab[#tab + 1] = v
							if v.Part1 and not istracked2(v.Part1) then
								track(v.Part1)
							end
						end
					end
				end
				track(ud.RootPart)
				for i,v in next, tab do
					v:Destroy()
				end
			end
		elseif typeof(ud) == "RBXScriptSignal" and b:lower() == "connect" then
			return function(a,func1,cond)
				if cond and type(cond) == "userdata" and iscond(cond) then
					local tab1 = {}
					local con = ud:Connect(function(...) local a = vwrap({...}) if cond.Cast(unpack1(a)) then func1(unpack1(a)) end end)
					return con
				else
					local tab1 = {}
					local con = ud:Connect(function(...) local a = vwrap({...}) func1(unpack1(a)) end)
					return con
				end
			end
		elseif typeof(ud) == "RBXScriptSignal" and b:lower() == "wait" then
			return function(inst,time1,cond)
			if cond and iscond(cond) then
				local eve = Instance.new("BindableEvent")
				local func1 = inst:Connect(function(...)
					local a = vwrap({...})
					if cond.Cast(unpack1(a)) then
						eve:Fire(unpack1(a))
						eve:Destroy()
					end
				end)
				local val = ({eve.Event:Wait(time1)})
				if eve then
					eve:Destroy()
				end
				func1:Disconnect()
				if #val ==0 then
					return nil
				end
				return unpack(val)
			else
				return inst:Wait(time1)
			end
end
		end
		if pcall(function() if not ud[b] then return error("!") end return ud[b] end) then
			local val = ud[b]
			local typ = type(val)
			local typ2 = typeof(val)
			if typ == "userdata" and typ2 == "Instance" then
				return wrap(val)
			elseif typ == "function" then
				if pcall(function() return val() end) then
					return function(...) local a = vunwrap({...}) return unpack1(vwrap({val(unpack1(a))})) end
				else
					if b == "FindFirstChildWhichIsA" then
						return nil
					elseif b == "FindFirstChildOfClass" then
						return nil
					elseif b == "FindFirstAncestorWhichIsA" then
						return nil
					elseif b == "FindFirstAncestorOfClass" then
						return nil
					end
					end
					return function(...) local a = vunwrap({...}) if a[1] ~= ud then return (function(...) local c = vwrap({ud[b](...)}) c = unpack1()(c) return unpack1(c) end)(ud,unpack1(a)) else return (function(...) local c = vwrap({ud[b](...)}) return unpack1(c) end)(unpack1(a)) end end
			else
				return vwrap(val)
			end
			else
				if typeof(ud) == "Instance" and ud.ClassName == "Player" and plrlib[ud.Name][b] then
					return envvalwrap2(plrlib[ud.Name][b])
				end
				if typeof(ud) == "Instance" and ud.ClassName == "Players" and b == "GetInfo" then
					return envvalwrap2(plrlib.GetInfo)
				end
			end
		end
	
	meta.__newindex = function(a,b,c)
		if not iscond(ud) then
			c = vunwrap(c)
		end
		if typeof(ud) == "Region3" then
			if b:lower() == "cframe" then
				local tab = GetMaxMinCorners(c,ud.Size)
				local a = Region3.new(tab.Min,tab.Max)
				ud = a
				udnum = #Index.Tab + 1
				Index.Tab[udnum] = ud
			elseif b:lower() == "size" then
				local tab = GetMaxMinCorners(ud.CFrame,c)
				local a = Region3.new(tab.Min,tab.Max)
				ud = a
				udnum = #Index.Tab + 1
				Index.Tab[udnum] = ud  
			end
		else
			ud[b] = c
			return true
		end
	end
	meta.__tostring = function(a)
		local th = vwrap(vunwrap(tostring(ud)))
		return th
	end
	meta.__tonumber = function(a)
		local th = vwrap(vunwrap(tonumber(ud)))
		return th
	end
	meta.__add = function(a,b)
		local th = vwrap(ud + vunwrap(b))
		return th
	end
	meta.__sub = function(a,b)
		local th = vwrap(ud - vunwrap(b))
		return th
	end
	meta.__mul = function(a,b)
		local th = vwrap(ud*vunwrap(b))
		return th
	end
	meta.__unm = function(a)
		local th = vwrap(vunwrap(-ud))
		return th
	end
	meta.__div = function(a,b)
		local th = vwrap(ud/vunwrap(b))
		return th
	end
	meta.__mod = function(a,b)
		local th = vwrap(ud%vunwrap(b))
		return th
	end
	meta.__pow = function(a,b)
		local th  = vwrap(ud^vunwrap(b))
		return th
	end
	meta.__eq = function(a,b)
		local th = vwrap((ud == vunwrap(b)))
		return th
	end
	meta.__it = function(a,b)
		local th = vwrap((ud < vunwrap(b)))
		return th
	end
	meta.__le = function(a,b)
		local th = vwrap((ud <= vunwrap(b)))
		return th
	end
	meta.__concact = function(a,b)
		local th = vwrap((ud ..vunwrap(b)))
		return th
	end
	meta.__call = function(a,...)
		local th = vwrap({ud(unpack1(vunwrap({...})))})
		return unpack1(th)
	end
	meta.__metatable = "sandboxed"
	meta.__len = function(a)
		local th = vwrap(vunwrap(#ud))
		return th
	end
	udnum = #Index.Tab + 1
	Index.Tab[udnum] = ud
	return nud
	end
return function(env)
	local fenv = env or getfenv(2)
	local script2 = fenv.script
	envwrap(fenv)
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
		</Item>
	</Item>
</roblox>
