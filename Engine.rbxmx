<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<Meta name="ExplicitAutoJoints">true</Meta>
	<External>null</External>
	<External>nil</External>
	<Item class="Folder" referent="RBXE9954F37C7A646B9A9182B9510573DDC">
		<Properties>
			<string name="Name">Files</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Configuration" referent="RBX8CDD6625280C4C139C58DDB88605042D">
			<Properties>
				<string name="Name">StarterPlayer</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Configuration" referent="RBXA321DD6AFD6D4367BB7086D30D931DC8">
				<Properties>
					<string name="Name">StarterPlayerScripts</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="LocalScript" referent="RBX9FE6D4B85FA44AAEB0A749484AA59493">
					<Properties>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">PlrProbe</string>
						<string name="ScriptGuid">{0D720DAB-7A66-47B8-82BE-0015071A4597}</string>
						<ProtectedString name="Source"><![CDATA[joy1 = {}
joy1.Delta = Vector3.new(0,0,0)
joy1.Position = Vector3.new(0,0,0)
joy2 = {}
joy2.Delta = Vector3.new(0,0,0)
joy2.Position = Vector3.new(0,0,0)
plr = game.Players.LocalPlayer
mouse = plr:GetMouse()
camera = workspace.CurrentCamera
idle = 0
uis = game:GetService("UserInputService")
uis.InputChanged:Connect(function(input,gp)
	if input.KeyCode == Enum.KeyCode.Thumbstick1 then
		joy1.Delta = input.Delta
		joy1.Position = input.Position
	elseif input.KeyCode == Enum.KeyCode.Thumbstick2 then
		joy2.Delta = input.Delta
		joy2.Position = input.Position
	end
end)
uis.InputBegan:Connect(function(input, gpe)
	game.ReplicatedStorage.Events.Players:WaitForChild(plr.Name).KeyDown:FireServer(input.KeyCode)
end)
uis.InputEnded:Connect(function(input, gpe)
	game.ReplicatedStorage.Events.Players:WaitForChild(plr.Name).KeyUp:FireServer(input.KeyCode)
end)
mouse.Button1Down:Connect(function() game.ReplicatedStorage.Events.Players:WaitForChild(plr.Name).b1d:FireServer() end)
mouse.Button1Up:Connect(function() game.ReplicatedStorage.Events.Players:WaitForChild(plr.Name).b1u:FireServer() end)
mouse.Button2Down:Connect(function() game.ReplicatedStorage.Events.Players:WaitForChild(plr.Name).b2d:FireServer() end)
mouse.Button2Up:Connect(function() game.ReplicatedStorage.Events.Players:WaitForChild(plr.Name).b2d:FireServer() end)
mouse.Move:Connect(function() idle = 1 end)
mouse.Idle:Connect(function() idle = 0 end)
plr.Chatted:Connect(function(msg) game.ReplicatedStorage.Events.Players:WaitForChild(plr.Name).Chat:FireServer(msg) end)
tabinput = {}
while wait(1/30) do
	local gui
	if uis:GetFocusedTextBox() then
		gui = true
	else
		gui = false
	end
	game.ReplicatedStorage.Events.Players:WaitForChild(plr.Name).joystick:FireServer(joy1,joy2)
	tabinput = {Accelerometer = uis.AccelerometerEnabled,Gamepad = uis.GamepadEnabled,Gyroscope = uis.GyroscopeEnabled,Keyboard = uis.KeyboardEnabled,Modal = uis.ModalEnabled,Mouse = uis.MouseEnabled,Touch = uis.TouchEnabled,VR = uis.VREnabled}
	game.ReplicatedStorage.Events.Players:WaitForChild(plr.Name).gui:FireServer(gui)
	game.ReplicatedStorage.Events.Players:WaitForChild(plr.Name).type:FireServer(tabinput)
	game.ReplicatedStorage.Events.Players:WaitForChild(plr.Name).Mouse:FireServer(mouse.hit, mouse.target, mouse.origin)
	if idle == 1 then
		game.ReplicatedStorage.Events.Players:WaitForChild(plr.Name).mMove:FireServer()
	else
		game.ReplicatedStorage.Events.Players:WaitForChild(plr.Name).mIdle:FireServer()
	end
	game.ReplicatedStorage.Events.Players:WaitForChild(plr.Name).Camera:FireServer(camera.CFrame)
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="Configuration" referent="RBX29F41432A98C4B618C1AAAB12CE21651">
			<Properties>
				<string name="Name">ReplicatedStorage</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Folder" referent="RBX7B9845A7ED17413D88BDFDB5EEF754A1">
				<Properties>
					<string name="Name">Events</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBX1F49D8A2153B4C5FA36077D0995B7499">
					<Properties>
						<string name="Name">Players</string>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX4527B150150F431AB47E87035584B272">
				<Properties>
					<string name="Name">PlayerFold</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBX9C4C081CC8A148EFA37FEB8A1F06613B">
					<Properties>
						<string name="Name">Folder</string>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="RemoteEvent" referent="RBX300AAF7EE3774822A168B444818DC88F">
						<Properties>
							<string name="Name">Camera</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBXD8485D224D8C4D649644B8E61E4C8877">
						<Properties>
							<string name="Name">Chat</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBXBD6E21F9CEC749EBAD07C13092F94E95">
						<Properties>
							<string name="Name">KeyDown</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBXDC7DC67B2D0841DC8F6E5F46F8C67D92">
						<Properties>
							<string name="Name">KeyUp</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBXA995D52B5E59485E990D4E57E86FAE9C">
						<Properties>
							<string name="Name">Mouse</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX21B2B092E246490792840CA893220D78">
						<Properties>
							<string name="Name">b1d</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX130794C3885A4CC9ADEF09F1A0884D67">
						<Properties>
							<string name="Name">b1u</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBXCBAF21A4113D42C6BB74D8F6A8E55A08">
						<Properties>
							<string name="Name">b2d</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX0FE82698AC534B2AABB0B75A061D59FA">
						<Properties>
							<string name="Name">b2u</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX0C1896E441B64CCDA108699621AD39AB">
						<Properties>
							<string name="Name">mIdle</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX087908A27EF24D86ADE2A7EA5FB7D144">
						<Properties>
							<string name="Name">mMove</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXE6872E1626A649609D5001B8CE1E31AD">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Input</string>
							<string name="ScriptGuid">{5794C165-900A-4DA8-B256-97008917FC3B}</string>
							<ProtectedString name="Source"><![CDATA[modtable = {}
local cc = script.Parent
plr = game.Players[script.Parent.Name]
Mouse = {}
Mouse.hit = CFrame.new()
Mouse.target = nil
Mouse.origin = CFrame.new()
cc.Mouse.OnServerEvent:Connect(function(p, m1, m2, m3)
	if p ~= plr then return end
	modtable.MouseCframe = m1
	modtable.MouseTarget = m2
	modtable.MouseOrigin = m3
end)
local mkd = Instance.new("BindableEvent", cc)
local mku = Instance.new("BindableEvent", cc)
cc.KeyDown.OnServerEvent:Connect(function(p, k) if p ~= plr then return end mkd:Fire(k) end)
cc.KeyUp.OnServerEvent:Connect(function(p, k) if p ~= plr then return end mku:Fire(k) end)
modtable.KeyDown = mkd.Event
modtable.KeyUp = mku.Event
modtable.Button1Down = Instance.new("BindableEvent",cc)
modtable.Button1Up = Instance.new("BindableEvent",cc)
modtable.Button2Down = Instance.new("BindableEvent",cc)
modtable.Button2Up = Instance.new("BindableEvent",cc)
cc.b1d.OnServerEvent:Connect(function(p)
	if p ~= plr then return end
	modtable.Button1Down:Fire()
end)
cc.b1u.OnServerEvent:Connect(function(p)
	if p ~= plr then return end
	modtable.Button1Up:Fire()
end)
cc.b2d.OnServerEvent:Connect(function(p)
	if p ~= plr then return end
	modtable.Button2Down:Fire()
end)
cc.b2u.OnServerEvent:Connect(function(p)
	if p ~= plr then return end
	modtable.Button2Up:Fire()
end)
Camera = {}
modtable.CameraCframe = CFrame.new()
local mm = Instance.new("BindableEvent", cc)
local mi = Instance.new("BindableEvent", cc)
cc.Camera.OnServerEvent:Connect(function(p,val) if p ~= plr then return end modtable.CameraCframe = val end)
local ms = true
cc.mMove.OnServerEvent:Connect(function(p) if p ~= plr then return end ms = 1 end)
cc.mIdle.OnServerEvent:Connect(function(p) if p ~= plr then return end ms = 0 end)
local function mousem() 
	if ms == 1 then
		mm:Fire()
	elseif ms == 0 then
		mi:Fire()
	end
end
game:GetService('RunService').Heartbeat:Connect(mousem)
modtable.MouseMove = mm.Event
modtable.MouseIdle = mi.Event
local chat = Instance.new("BindableEvent", script)
cc.Chat.OnServerEvent:Connect(function(p, msg) if p ~= plr then return end chat:Fire(msg) end)
modtable.Chatted = chat.Event
modtable.Type = nil
modtable.IsInGui = false
cc.gui.OnServerEvent:Connect(function(p,gui)
	if p ~= plr then return end
	modtable.IsInGui = gui
end)
cc.type.OnServerEvent:Connect(function(p,type1)
	if p ~= plr then return end
	modtable.Type = type1
	for i,v in ipairs(type1) do
			print(v)
	end
end)
modtable.JoyStick1 = nil
modtable.JoyStick2 = nil
cc.type.OnServerEvent:Connect(function(p,joy1,joy2)
	if p ~= plr then return end
	modtable.JoyStick1 = joy1
	modtable.JoyStick2 = joy2
end)


return modtable

--[[
## DEFINITIONS
The term, "StormDirus" can be defined in two ways:
1. The account holder of the Github account, that can be found at this URL:
https://github.com/StormDirus

2. The account holder of the Roblox account, that can be found at this URL:
https://www.roblox.com/users/49946095/profile

The term, "Repository" is the Github repository held in this URL:
https://github.com/StormDirus/DirusEngine



## LICENSE AGREEMENT
Copyright (c) 2019 StormDirus
This work may be distributed and/or modified under the
conditions of the LaTeX Project Public License, either version 1.3
of this license or (at your option) any later version.
The latest version of this license is in
http://www.latex-project.org/lppl.txt 
and version 1.3 or later is part of all distributions of LaTeX version 2005/12/01 or later.
This work has the LPPL maintenance status 'maintained'.
The Current Maintainer of this work is StormDirus.
--]]]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX70CE92C1687C49569780B3D8AEC12B31">
						<Properties>
							<string name="Name">type</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX94A1047D45BA4E00A382C6C6ADC870CE">
						<Properties>
							<string name="Name">gui</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX5064E50F48154106AB2F2B43CED6B08E">
						<Properties>
							<string name="Name">joystick</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
		</Item>
		<Item class="Configuration" referent="RBX7251F58CC2C1494B8E805C6F2FC1D47E">
			<Properties>
				<string name="Name">ServerScriptService</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Script" referent="RBXA13B554560844289BB589155223D6D56">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">DirusEngine</string>
					<string name="ScriptGuid">{A46BF7E0-1112-430D-A72C-514990BF50CE}</string>
					<ProtectedString name="Source"><![CDATA[game.Players.PlayerAdded:Connect(function(plr)
	local fold = game.ReplicatedStorage.PlayerFold.Folder:Clone()
	fold.Name = plr.Name
	fold.Parent = game.ReplicatedStorage.Events.Players
end)
engine = require(script.Main)

--[[
## DEFINITIONS
The term, "StormDirus" can be defined in two ways:
1. The account holder of the Github account, that can be found at this URL:
https://github.com/StormDirus

2. The account holder of the Roblox account, that can be found at this URL:
https://www.roblox.com/users/49946095/profile

The term, "Repository" is the Github repository held in this URL:
https://github.com/StormDirus/DirusEngine



## LICENSE AGREEMENT
Copyright (c) 2019 StormDirus
This work may be distributed and/or modified under the
conditions of the LaTeX Project Public License, either version 1.3
of this license or (at your option) any later version.
The latest version of this license is in
http://www.latex-project.org/lppl.txt 
and version 1.3 or later is part of all distributions of LaTeX version 2005/12/01 or later.
This work has the LPPL maintenance status 'maintained'.
The Current Maintainer of this work is StormDirus.
--]]
]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX3C27CAC1444C440991152FEC3673B9F4">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Main</string>
						<string name="ScriptGuid">{A68A7167-2B88-40B8-ABFD-4888C7C8FB93}</string>
						<ProtectedString name="Source"><![CDATA[modtable = {}
modtable.ValueLib = require(script.ValueLib)
modtable.InstanceLib = require(script.InstanceLib)
modtable.PlayerLib = require(script.PlayerLib)
modtable.CharacterLib = require(script.CharacterLib)
return modtable

--[[
## DEFINITIONS
The term, "StormDirus" can be defined in two ways:
1. The account holder of the Github account, that can be found at this URL:
https://github.com/StormDirus

2. The account holder of the Roblox account, that can be found at this URL:
https://www.roblox.com/users/49946095/profile

The term, "Repository" is the Github repository held in this URL:
https://github.com/StormDirus/DirusEngine



## LICENSE AGREEMENT
Copyright (c) 2019 StormDirus
This work may be distributed and/or modified under the
conditions of the LaTeX Project Public License, either version 1.3
of this license or (at your option) any later version.
The latest version of this license is in
http://www.latex-project.org/lppl.txt 
and version 1.3 or later is part of all distributions of LaTeX version 2005/12/01 or later.
This work has the LPPL maintenance status 'maintained'.
The Current Maintainer of this work is StormDirus.
--]]

]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXE8D4FD63F37444BEAC5C90540330400C">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">PlayerLib</string>
							<string name="ScriptGuid">{2917E405-7D80-4609-A959-928222788C76}</string>
							<ProtectedString name="Source"><![CDATA[modtable = {}
game.ReplicatedStorage.Events.Players.ChildAdded:Connect(function(obj)
	modtable[obj.Name] = {}
	modtable[obj.Name].Input = require(obj.Input)
	game.Players.PlayerRemoving:Connect(function(plr)
		if not obj then return end
		if plr.Name == obj.Name then
			obj:Remove()
		end
	end)
end)
return modtable

--[[
## DEFINITIONS
The term, "StormDirus" can be defined in two ways:
1. The account holder of the Github account, that can be found at this URL:
https://github.com/StormDirus

2. The account holder of the Roblox account, that can be found at this URL:
https://www.roblox.com/users/49946095/profile

The term, "Repository" is the Github repository held in this URL:
https://github.com/StormDirus/DirusEngine



## LICENSE AGREEMENT
Copyright (c) 2019 StormDirus
This work may be distributed and/or modified under the
conditions of the LaTeX Project Public License, either version 1.3
of this license or (at your option) any later version.
The latest version of this license is in
http://www.latex-project.org/lppl.txt 
and version 1.3 or later is part of all distributions of LaTeX version 2005/12/01 or later.
This work has the LPPL maintenance status 'maintained'.
The Current Maintainer of this work is StormDirus.
--]]
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXA1388A6986F94568BC64CD4F5084A119">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">InstanceLib</string>
							<string name="ScriptGuid">{3D052976-4BD4-48BF-8A1C-01863C36A84B}</string>
							<ProtectedString name="Source"><![CDATA[local modtable = {}
valuelib = require(script.Parent.ValueLib)
function modtable:GetAncestors(obj)
	if obj.Parent then
		local a = obj.Parent
		local b = {}
		repeat
			table.insert(b,a)
			a = a.Parent
		until a == nil
		return b
	end
end
function modtable:FindFirstChildWithFunc(obj,func)
	for i,v in ipairs(obj:GetChildren()) do
		if func(v) == true then
			return v
		end
	end
end
function modtable:FindFirstDescendantWithFunc(obj,func)
	for i,v in ipairs(obj:GetDescendants()) do
		if func(v) == true then
			return v
		end
	end
end
function modtable:FindFirstAncestorWithFunc(obj,func)
	for i,v in ipairs(modtable:GetAncestors(obj)) do
		if func(v) == true then
			return v
		end
	end
end
function modtable:GetChildrenWithFunc(obj,func)
	local tab = {}
	for i,v in ipairs(obj:GetChildren()) do
		if func(v) == true then
			table.insert(tab,v)
		end
	end
	return tab
end
function modtable:GetDescendantsWithFunc(obj,func)
	local tab = {}
	for i,v in ipairs(obj:GetDescendants()) do
		if func(v) == true then
			table.insert(tab,v)
		end
	end
	return tab
end
function modtable:GetAncestorsWithFunc(obj,func)
	local tab = {}
	for i,v in ipairs(modtable:GetAncestors()) do
		if func(v) == true then
			table.insert(tab,v)
		end
	end
	return tab
end
function modtable:WaitForDescendantWithFunc(obj,func,time1)
	for i,v in ipairs(obj:GetDescendants()) do
		if func(v) == true then
			return v
		end
	end
	local eve = Instance.new("BindableEvent")
	local func1 = obj.DescendantAdded:Connect(function(obj2)
		for i,v in ipairs(obj:GetDescendants()) do
			if func(v) == true then
				eve:Fire(v)
				eve:Destroy()
			end
		end
	end)
	local val = eve.Event:wait(time1)
	func1:disconnect()
	return val
end
function modtable:WaitForChildWithFunc(obj,func,time1)
	for i,v in ipairs(obj:GetChildren()) do
		if func(v) == true then
			return v
		end
	end
	local eve = Instance.new("BindableEvent")
	local func1 = obj.ChildAdded:Connect(function(obj2)
		for i,v in ipairs(obj:GetDescendants()) do
			if func(v) == true then
				eve:Fire(v)
				eve:Destroy()
			end
		end
	end)
	local val = eve.Event:wait(time1)
	func1:disconnect()
	return val
end
function modtable:WaitForAncestorWithFunc(obj,func,time1)
	for i,v in ipairs(obj:GetDescendants()) do
		if func(v) == true then
			return v
		end
	end
	local eve = Instance.new("BindableEvent")
	local func1 = obj.AncestryChanged():Connect(function(obj2)
		for i,v in ipairs(modtable:GetAncestors(obj)) do
			if func(v) == true then
				eve:Fire(v)
				eve:Destroy()
			end
		end
	end)
	local val = eve.Event:wait(time1)
	func1:disconnect()
	return val
end
function modtable:GetInstancesWithFunc(obj,func)
	local tab = {}
	for i,v in ipairs(valuelib:GetIndex()) do
		if func(v) == true then
			table.insert(tab,v)
		end
	end
	return tab
end
function modtable.Create(objclass,parent,param1,param2)
	local obj = Instance.new(objclass,parent)
	for i,v in ipairs(param1) do
		obj[v] = param2[i]
	end
	return obj
end




return modtable

--[[
## DEFINITIONS
The term, "StormDirus" can be defined in two ways:
1. The account holder of the Github account, that can be found at this URL:
https://github.com/StormDirus

2. The account holder of the Roblox account, that can be found at this URL:
https://www.roblox.com/users/49946095/profile

The term, "Repository" is the Github repository held in this URL:
https://github.com/StormDirus/DirusEngine



## LICENSE AGREEMENT
Copyright (c) 2019 StormDirus
This work may be distributed and/or modified under the
conditions of the LaTeX Project Public License, either version 1.3
of this license or (at your option) any later version.
The latest version of this license is in
http://www.latex-project.org/lppl.txt 
and version 1.3 or later is part of all distributions of LaTeX version 2005/12/01 or later.
This work has the LPPL maintenance status 'maintained'.
The Current Maintainer of this work is StormDirus.
--]]
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX8C577F71CC2B45E8902CCC3F1D764E76">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ValueLib</string>
							<string name="ScriptGuid">{1508B35D-2779-4EF5-8FA5-4CDB6DE881AF}</string>
							<ProtectedString name="Source"><![CDATA[modtable = {}
Index = {}
Index[1] = game
local indexnum = 1
for i,v in ipairs(game:GetDescendants()) do
	indexnum = indexnum + 1
	Index[indexnum] = v
end
game.DescendantAdded:Connect(function(obj)
	indexnum = indexnum + 1
	Index[indexnum] = obj
end)
function modtable:GetUserDataId(obj)
	for i,v in ipairs(Index) do
		if v == obj then
			return i
		end
	end
end
function modtable:GetIndex()
	return Index
end
function modtable:GetUserDataFromId(num)
	if Index[num] then
		return Index[num]
	end
end
function modtable:CreateFilteredTableClone(tab,func)
	local tab2 = {}
	for i,v in ipairs(tab) do
		if func(v) == true then
			table.insert(tab2,v)
		end
	end
	return tab2
end
function modtable.TableContains(tab,func)
	for i,v in ipairs(tab) do
		if func(v) == true then
			return i
		end
	end
end
return modtable

--[[
## DEFINITIONS
The term, "StormDirus" can be defined in two ways:
1. The account holder of the Github account, that can be found at this URL:
https://github.com/StormDirus

2. The account holder of the Roblox account, that can be found at this URL:
https://www.roblox.com/users/49946095/profile

The term, "Repository" is the Github repository held in this URL:
https://github.com/StormDirus/DirusEngine



## LICENSE AGREEMENT
Copyright (c) 2019 StormDirus
This work may be distributed and/or modified under the
conditions of the LaTeX Project Public License, either version 1.3
of this license or (at your option) any later version.
The latest version of this license is in
http://www.latex-project.org/lppl.txt 
and version 1.3 or later is part of all distributions of LaTeX version 2005/12/01 or later.
This work has the LPPL maintenance status 'maintained'.
The Current Maintainer of this work is StormDirus.
--]]
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX9ED9F7EBC5A249DA8D76078C39306D4A">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">CharacterLib</string>
							<string name="ScriptGuid">{0944B5FD-6670-4C6E-BA01-8E9A45C0EDEB}</string>
							<ProtectedString name="Source"><![CDATA[modtable = {}
inst = require(script.Parent.InstanceLib)
pathfinddebounce = {}
pathfindingcache = {}
animcache = {}
animcache.hums = {}
index = require(script.Parent.ValueLib)
function modtable:GetPlayerFromObj(obj)
	if not game.Players:GetPlayerFromCharacter(obj) then
		local obj2 = inst:FindFirstAncestorWithFunc(obj,function(obj1) if game.Players:GetPlayerFromCharacter(obj1) then return true end end)
		if obj2 then
			local val = game.Players:GetPlayerFromCharacter(obj2)
			return val
		end
	else
		local val = game.Players:GetPlayerFromCharacter(obj)
		return val
	end
end
function modtable:GetHumanoidFromPlayer(plr)
	local char = plr.Character
	if char then
		local hum = inst:FindFirstDescendantWithFunc(char,function(obj1) if obj1:IsA("Humanoid") then return true end end)
		if hum then return hum end
	end
end
	function modtable:StartPathFind(hum, despoint)
		local indexnum = index:GetUserDataId(hum)
		if not pathfinddebounce[indexnum] then
			pathfinddebounce[indexnum] = 0
		end
		if pathfinddebounce[indexnum] == 1 then return end
		if pathfindingcache[indexnum] then
			pathfindingcache[indexnum].isdone = 1
			repeat game:GetService("RunService").Heartbeat:wait() until pathfindingcache[indexnum] == nil
			pathfindingcache[indexnum] = {}
			pathfindingcache[indexnum].isdone = 0
		else
			pathfindingcache[indexnum] = {}
			pathfindingcache[indexnum].isdone = 0
		end
		pathfinddebounce[indexnum] = 1
		if pcall(function() return despoint.Position end) then
			despoint = despoint.Position
		end
		local PathfindingService = game:GetService("PathfindingService")
    	local connect = {}
    	 
		local path = PathfindingService:CreatePath()
    	local waypoints
    	local currentWaypointIndex
    	
		local function waypointcheck(num1, num2)
			if CFrame.new(hum.RootPart.Position,num1).LookVector == CFrame.new(num1,num2).LookVector then
				return 1
			else
				return 0
			end
		end
    	
		local function followPath()
			path = PathfindingService:CreatePath()
    		path:ComputeAsync(hum.RootPart.Position, despoint)
    		waypoints = {}
    		if path.Status == Enum.PathStatus.Success then
    			waypoints = path:GetWaypoints()
    			currentWaypointIndex = 1
				repeat
				currentWaypointIndex = currentWaypointIndex + 1
				if not waypoints[currentWaypointIndex + 2] then
					break
				end
			until waypointcheck(waypoints[currentWaypointIndex].Position,waypoints[currentWaypointIndex + 1].Position) == 0
    			hum:MoveTo(waypoints[currentWaypointIndex].Position)
				if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then
					hum.Jump = true
				end
				pathfinddebounce[indexnum] = 0
    		else
    			hum:MoveTo(hum.RootPart.Position)
				pathfinddebounce[indexnum] = 0
    		end
   	 end
   	  
    	 
    	connect["onPathBlocked"] = path.Blocked:Connect(followPath)
    	 
    	connect["onWaypointReached"] = hum.MoveToFinished:Connect(followPath)
     	local function check()
			if pathfindingcache[indexnum].isdone == 1 then
				pathfinddebounce[indexnum] = 0
				connect["onPathBlocked"]:disconnect()
				connect["onWaypointReached"]:disconnect()
				pathfindingcache[indexnum] = nil
				connect["check"]:disconnect()
			end
		end
		connect["check"] = game:GetService("RunService").Heartbeat:Connect(check)
    	followPath()
	end
game:GetService("RunService").Heartbeat:Connect(function()
	for i,hum in ipairs(inst:GetDescendantsWithFunc(workspace,function(funcobj) if funcobj:IsA("Humanoid") or funcobj:IsA("AnimationController") then return true end end)) do
		local indexnum = index:GetUserDataId(hum)
		if animcache.hums[indexnum] then
			animcache.hums[indexnum].anims = hum:GetPlayingAnimationTracks()
		else
			animcache.hums[indexnum] = {}
		end
	end
end)
function modtable:CanPathFind(hum, despoint)
	if pcall(function() return despoint.Position end) then
		despoint = despoint.Position
	end
	local PathfindingService = game:GetService("PathfindingService")
	local path = PathfindingService:CreatePath()
    path:ComputeAsync(hum.RootPart.Position, despoint)
	return path.Status
end
function modtable:StopPathFind(hum)
	local indexnum = index:GetUserDataId(hum)
	if pathfindingcache[indexnum] then
		pathfindingcache[indexnum].isdone = 1
		repeat game:GetService("RunService").Heartbeat:wait() until pathfindingcache[indexnum] == nil
	end
end
function modtable:PlayAnim(hum,anim,speed,looped,weight,fade)
	if hum then
		if hum:IsA("Humanoid") or hum:IsA("AnimationController") then
		else
			local obj2 = inst.FindFirstDescendantWithFunc(hum,function(obj1) if obj1:IsA("Humanoid") or obj1:IsA("AnimationController") then return true end end)
			if obj2 then
				hum = obj2
			else
				if hum:FindFirstChild("HumanoidRootPart") then
					hum = Instance.new("Humanoid",hum)
				else
					hum = Instance.new("AnimationController",hum)
				end
			end
		end
		
	else
		error("Missing paramater.")
	end
	local anim2
	if string.find(tostring(anim),"rbxassetid://") or string.find(tostring(anim),"http://www.roblox.com/asset/?id=") then
		anim = inst.Create("Animation",game,{"AnimationId"},{anim})
		anim2 = hum:LoadAnimation(anim)
	elseif pcall(function() return anim.AnimationId end) then
		anim = anim.AnimationId
		anim = inst.Create("Animation",nil,{"AnimationId"},{tostring(anim)})
		anim2 = hum:LoadAnimation(anim)
	else
		anim2 = hum:LoadAnimation("rbxassetid://" ..(tostring(anim)))
	end
	if not anim2 then return end
	anim2.Looped = looped
	anim2:Play(fade,weight,speed)
	return anim2
end
function modtable:NewAnim(hum)
	local anim2
	if string.find(tostring(anim),"rbxassetid://") or string.find(tostring(anim),"http://www.roblox.com/asset/?id=") then
		anim = inst.Create("Animation",game,{"AnimationId"},{anim})
		anim2 = hum:LoadAnimation(anim)
	elseif pcall(function() return anim.AnimationId end) then
		anim = anim.AnimationId
		anim = inst.Create("Animation",nil,{"AnimationId"},{tostring(anim)})
		anim2 = hum:LoadAnimation(anim)
	else
		anim2 = hum:LoadAnimation("rbxassetid://" ..(tostring(anim)))
	end
	if not anim2 then return end
	return anim2
	end
function modtable:EditAnim(anim,speed,weight,fade,looped)
	if speed then
		anim:AdjustSpeed(speed)
	end
	if weight then
		anim:AdjustWeight(weight,fade)
	end
	if looped ~= nil then
		anim.Looped = looped
	end
end
return modtable

--[[
## DEFINITIONS
The term, "StormDirus" can be defined in two ways:
1. The account holder of the Github account, that can be found at this URL:
https://github.com/StormDirus

2. The account holder of the Roblox account, that can be found at this URL:
https://www.roblox.com/users/49946095/profile

The term, "Repository" is the Github repository held in this URL:
https://github.com/StormDirus/DirusEngine



## LICENSE AGREEMENT
Copyright (c) 2019 StormDirus
This work may be distributed and/or modified under the
conditions of the LaTeX Project Public License, either version 1.3
of this license or (at your option) any later version.
The latest version of this license is in
http://www.latex-project.org/lppl.txt 
and version 1.3 or later is part of all distributions of LaTeX version 2005/12/01 or later.
This work has the LPPL maintenance status 'maintained'.
The Current Maintainer of this work is StormDirus.
--]]
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
		</Item>
	</Item>
</roblox>
